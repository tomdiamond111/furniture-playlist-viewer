<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shared Furniture Playlist</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            overflow: hidden;
        }

        /* Smooth transitions for orientation changes */
        #playlist, #controls, #info-panel, #canvas-container {
            transition: all 0.3s ease-in-out;
        }
        
        /* Ensure elements stay within viewport during orientation changes */
        body.orientation-change {
            overflow: hidden;
        }
        
        body.orientation-change #playlist,
        body.orientation-change #controls,
        body.orientation-change #info-panel {
            pointer-events: none;
        }

        #container {
            position: fixed;
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            top: 0;
            left: 0;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        #info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            max-width: 350px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 50;
            transition: all 0.3s ease;
            display: block; /* Visible by default for desktop */
        }

        #info-panel.collapsed {
            padding: 10px;
            max-width: 60px;
            overflow: hidden;
        }

        #info-panel.collapsed .info-content {
            display: none !important;
        }

        #info-toggle-btn {
            background: rgba(102, 126, 234, 0.9);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            display: none;
            width: 100%;
        }

        #info-toggle-btn:hover {
            background: rgba(102, 126, 234, 1);
            transform: scale(1.05);
        }

        .logo-container {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 60;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .logo-container img {
            height: 40px;
            width: auto;
            display: block;
        }

        /* Google Play Badge */
        .google-play-badge {
            position: fixed;
            z-index: 60;
            bottom: 20px;
            right: 360px;
            transition: all 0.3s ease;
        }

        .google-play-badge img {
            height: 50px;
            width: auto;
            display: block;
            opacity: 0.9;
            transition: opacity 0.2s;
        }

        .google-play-badge img:hover {
            opacity: 1;
        }

        /* Standalone Info Button for landscape mode */
        #info-button-landscape {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 60;
            background: rgba(102, 126, 234, 0.9);
            border: none;
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        #info-button-landscape:hover {
            background: rgba(102, 126, 234, 1);
            transform: scale(1.05);
        }

        #info-button-landscape:active {
            transform: scale(0.98);
        }

        /* Modal backdrop overlay */
        #modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 900;
            display: none;
            backdrop-filter: blur(3px);
        }

        #modal-backdrop.visible {
            display: block;
        }

        /* Close button for modal */
        .modal-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .modal-close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        #info-panel h1 {
            font-size: 24px;
            margin-bottom: 8px;
            color: #fff;
        }

        #info-panel .subtitle {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 16px;
        }

        #info-panel .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 16px;
        }

        #info-panel .stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
        }

        #info-panel .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        #info-panel .stat-label {
            font-size: 12px;
            color: #ccc;
            margin-top: 4px;
        }

        #playlist {
            position: fixed;
            right: 20px;
            top: 20px;
            bottom: 20px;
            width: 320px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: calc(100vw - 40px);
            max-height: calc(100vh - 40px);
        }

        #playlist h2 {
            font-size: 18px;
            margin-bottom: 16px;
            color: #fff;
        }

        #controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            transform: none;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            display: flex;
            gap: 10px;
            align-items: center;
            max-width: calc(100vw - 20px);
            max-height: calc(100vh - 20px);
            z-index: 100;
        }

        #direction-pad {
            display: grid;
            grid-template-columns: repeat(3, 35px);
            grid-template-rows: repeat(3, 35px);
            gap: 3px;
        }

        #direction-pad button {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #direction-pad button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        #direction-pad button:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }

        #direction-pad button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .zoom-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .zoom-control label {
            font-size: 10px;
            color: #ccc;
        }

        #zoom-slider {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            width: 20px;
            height: 80px;
            background: rgba(255, 255, 255, 0.15);
            outline: none;
            border-radius: 8px;
        }

        #zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
        }

        #zoom-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .playlist-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .playlist-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(-4px);
        }

        .playlist-item.active {
            background: rgba(102, 126, 234, 0.3);
            border: 2px solid #667eea;
        }

        .playlist-item.local-media {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .playlist-item-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 6px;
            object-fit: cover;
            background: rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .playlist-item-info {
            flex: 1;
            min-width: 0;
        }

        .playlist-item-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .playlist-item-subtitle {
            font-size: 12px;
            color: #aaa;
            margin-top: 4px;
        }

        .playlist-item-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            margin-top: 4px;
        }

        .badge-youtube {
            background: #ff0000;
            color: #fff;
        }

        .badge-vimeo {
            background: #1ab7ea;
            color: #fff;
        }

        .badge-local {
            background: #888;
            color: #fff;
        }

        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            max-width: 500px;
        }

        #error-message h2 {
            color: #ff6b6b;
            margin-bottom: 16px;
        }

        #error-message p {
            color: #ccc;
            line-height: 1.6;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .view-toggle-btn {
            background: #667eea;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 16px;
            width: 100%;
            transition: all 0.2s;
        }

        .view-toggle-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .view-toggle-btn:active {
            transform: translateY(0);
        }

        .import-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 16px;
            width: 100%;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .import-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .import-btn:active {
            transform: translateY(0);
        }

        .import-btn-icon {
            font-size: 18px;
        }

        .download-section {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .download-section p {
            color: #ccc;
            font-size: 13px;
            margin-bottom: 12px;
        }

        .download-links {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .download-link {
            display: block;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.2s;
        }

        .download-link:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateX(3px);
        }

        .download-link-icon {
            margin-right: 6px;
        }

        .download-link.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
        }

        .download-link.primary:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* Mobile-only simplified info panel */
        #mobile-info-panel {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 12px;
            border-radius: 10px;
            max-width: 200px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            z-index: 50;
            font-size: 12px;
        }

        #mobile-info-panel h3 {
            font-size: 13px;
            margin: 0 0 10px 0;
            color: #fff;
            font-weight: 600;
        }

        .mobile-import-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: all 0.2s;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .mobile-import-btn:active {
            transform: scale(0.98);
        }

        .mobile-download-section {
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mobile-download-section p {
            color: #ccc;
            font-size: 10px;
            margin-bottom: 6px;
        }

        .mobile-download-link {
            display: block;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.2s;
            margin-bottom: 4px;
            text-align: center;
        }

        .mobile-download-link:active {
            background: rgba(255, 255, 255, 0.2);
        }

        .mobile-download-link.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
        }

        /* JavaScript-controlled visibility class */
        .hidden-by-js {
            display: none !important;
        }

        #track-list-view {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        #track-list-view h2 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #fff;
        }

        .track-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .track-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
        }

        .track-item-icon {
            font-size: 32px;
            flex-shrink: 0;
        }

        .track-item-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 6px;
            object-fit: cover;
            background: rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .track-item-info {
            flex: 1;
            min-width: 0;
        }

        .track-item-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }

        .track-item-subtitle {
            font-size: 13px;
            color: #aaa;
        }

        .back-to-3d-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #667eea;
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.2s;
        }

        .back-to-3d-btn:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateX(-5px);
        }
        
        /* Mobile Optimizations - Base styles for all mobile devices */
        @media (max-width: 768px) {
            /* Make controls more compact and position on lower left */
            #controls {
                position: fixed !important;
                bottom: 8px !important;
                left: 8px !important;
                padding: 8px !important;
                gap: 8px !important;
                transform: none !important;
                background: rgba(0, 0, 0, 0.4) !important;
                z-index: 100 !important;
            }
            
            #direction-pad {
                grid-template-columns: repeat(3, 32px) !important;
                grid-template-rows: repeat(3, 32px) !important;
                gap: 3px !important;
            }
            
            #direction-pad button {
                font-size: 14px !important;
            }
            
            .zoom-control {
                gap: 4px !important;
            }
            
            .zoom-control label {
                font-size: 9px !important;
            }
            
            #zoom-slider {
                height: 60px !important;
                width: 18px !important;
            }
            
            #zoom-slider::-webkit-slider-thumb {
                width: 18px !important;
                height: 18px !important;
            }
            
            #zoom-slider::-moz-range-thumb {
                width: 18px !important;
                height: 18px !important;
            }
        }
        
        /* Portrait mode - stack playlist at bottom */
        @media (max-width: 768px) and (orientation: portrait) {
            /* Hide desktop info panel and show mobile version */
            #info-panel {
                display: none !important;
            }

            #mobile-info-panel {
                display: block !important;
            }

            .logo-container {
                top: 10px !important;
                right: 10px !important;
            }

            .logo-container img {
                height: 35px !important;
            }

            /* Google Play Badge - position in top left, away from logo */
            .google-play-badge {
                top: 10px !important;
                left: 10px !important;
                right: auto !important;
                bottom: auto !important;
            }

            .google-play-badge img {
                height: 40px !important;
            }

            #playlist {
                position: fixed !important;
                left: 8px !important;
                right: 8px !important;
                bottom: 8px !important;
                top: auto !important;
                width: auto !important;
                max-width: calc(100vw - 16px) !important;
                height: 150px !important;
                max-height: 150px !important;
                overflow-x: auto !important;
                overflow-y: hidden !important;
                white-space: nowrap !important;
                padding: 10px !important;
                font-size: 12px !important;
                display: block !important;
            }
            
            #playlist h2 {
                font-size: 13px !important;
                margin-bottom: 8px !important;
            }
            
            .playlist-item {
                display: inline-flex !important;
                width: 170px !important;
                vertical-align: top !important;
                margin-right: 8px !important;
                margin-bottom: 0 !important;
                padding: 8px !important;
                gap: 8px !important;
            }
            
            .playlist-item-thumbnail {
                width: 40px !important;
                height: 40px !important;
            }
            
            .playlist-item-title {
                font-size: 11px !important;
            }
            
            .playlist-item-subtitle {
                font-size: 9px !important;
            }
            
            /* Keep controls on lower left but move up to avoid playlist */
            #controls {
                position: fixed !important;
                bottom: 168px !important;
                left: 8px !important;
                transform: none !important;
                max-width: calc(100vw - 16px) !important;
            }
        }
        
        /* Landscape mode - playlist on right side */
        /* Use max-height instead of max-width for landscape since mobile landscape can have width > 768px */
        @media (max-height: 500px) and (orientation: landscape) {
            /* Hide desktop info panel and show mobile version */
            #info-panel {
                display: none !important;
            }

            #mobile-info-panel {
                display: block !important;
            }

            /* Hide the standalone info button - not needed anymore */
            #info-button-landscape {
                display: none !important;
            }

            .logo-container {
                top: 5px !important;
                right: 5px !important;
            }

            .logo-container img {
                height: 30px !important;
            }

            /* Google Play Badge - position bottom left, before controls */
            .google-play-badge {
                bottom: 5px !important;
                left: 5px !important;
                right: auto !important;
                top: auto !important;
            }

            .google-play-badge img {
                height: 35px !important;
            }

            #playlist {
                position: fixed !important;
                right: 5px !important;
                top: 45px !important;
                bottom: 5px !important;
                left: auto !important;
                width: 240px !important;
                max-width: 240px !important;
                height: auto !important;
                max-height: calc(100vh - 50px) !important;
                overflow-x: hidden !important;
                overflow-y: auto !important;
                white-space: normal !important;
                padding: 10px !important;
                font-size: 12px !important;
                display: block !important;
            }
            
            #playlist h2 {
                font-size: 14px !important;
                margin-bottom: 8px !important;
            }
            
            .playlist-item {
                display: flex !important;
                width: auto !important;
                margin-right: 0 !important;
                margin-bottom: 8px !important;
                padding: 8px !important;
                gap: 8px !important;
            }
            
            .playlist-item-thumbnail {
                width: 48px !important;
                height: 48px !important;
            }
            
            .playlist-item-title {
                font-size: 11px !important;
                line-height: 1.3 !important;
            }
            
            .playlist-item-subtitle {
                font-size: 9px !important;
            }
            
            .playlist-item-badge {
                font-size: 8px !important;
                padding: 2px 4px !important;
            }
            
            /* Controls stay on lower left - smaller and more compact */
            #controls {
                position: fixed !important;
                bottom: 5px !important;
                left: 65px !important;
                padding: 6px !important;
                gap: 6px !important;
                transform: none !important;
                max-width: calc(100vw - 320px) !important;
                max-height: calc(100vh - 10px) !important;
                background: rgba(0, 0, 0, 0.6) !important;
            }
            
            #direction-pad {
                grid-template-columns: repeat(3, 30px) !important;
                grid-template-rows: repeat(3, 30px) !important;
                gap: 2px !important;
            }
            
            #direction-pad button {
                font-size: 13px !important;
                border-radius: 5px !important;
            }
            
            .zoom-control {
                gap: 4px !important;
            }
            
            .zoom-control label {
                font-size: 9px !important;
            }
            
            #zoom-slider {
                height: 60px !important;
                width: 18px !important;
            }
            
            #zoom-slider::-webkit-slider-thumb {
                width: 18px !important;
                height: 18px !important;
            }
            
            #zoom-slider::-moz-range-thumb {
                width: 18px !important;
                height: 18px !important;
            }
        }
        
        /* Desktop and Tablet - hide mobile elements */
        /* Only hide mobile panel on true desktop/tablet (not small mobile screens) */
        @media (min-width: 769px) and (min-height: 501px) {
            #mobile-info-panel {
                display: none !important;
            }
            
            #info-button-landscape {
                display: none !important;
            }
            
            #modal-backdrop {
                display: none !important;
            }
        }
        
        /* Tablet adjustments */
        @media (min-width: 769px) and (max-width: 1024px) {
            #info-panel {
                max-width: 280px;
                padding: 16px;
                top: 15px;
                left: 15px;
            }
            
            #info-panel h1 {
                font-size: 20px;
            }
            
            #playlist {
                width: 280px;
                top: 15px;
                right: 15px;
                bottom: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <!-- Logo -->
        <div class="logo-container">
            <img src="FirstTapsMV3D_logo1.jpg" alt="FirstTaps MV3D">
        </div>

        <!-- Google Play Badge -->
        <a href="https://play.google.com/store/apps/details?id=com.firsttaps.firsttapsmv3d&pcampaignid=web_share" target="_blank" rel="noopener" class="google-play-badge">
            <img src="https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png" alt="Get it on Google Play">
        </a>

        <!-- Old info button removed - using simplified mobile panel instead -->
        <!-- <button id="info-button-landscape" onclick="window.furnitureViewer.toggleInfoPanel()" style="display: none;">‚ÑπÔ∏è Info</button> -->

        <!-- Old modal backdrop removed - not needed with simplified panel -->
        <!-- <div id="modal-backdrop" onclick="window.furnitureViewer.closeInfoPanel()"></div> -->

        <div id="loading">
            <div class="spinner"></div>
            <p>Loading shared furniture...</p>
        </div>

        <div id="error-message" style="display: none;">
            <h2>‚ö†Ô∏è Unable to Load Furniture</h2>
            <p id="error-text"></p>
        </div>

        <div id="info-panel">
            <!-- Old toggle buttons removed -->
            <!-- <button class="modal-close-btn" onclick="window.furnitureViewer.closeInfoPanel()" style="display: none;">√ó</button> -->
            <!-- <button id="info-toggle-btn" onclick="window.furnitureViewer.toggleInfoPanel()">‚ÑπÔ∏è</button> -->
            <div class="info-content">
                <h1 id="furniture-name">Loading...</h1>
                <div class="subtitle" id="furniture-type"></div>
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="total-objects">0</div>
                        <div class="stat-label">Total Items</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="youtube-count">0</div>
                        <div class="stat-label">YouTube Videos</div>
                    </div>
                </div>
                <button class="view-toggle-btn" onclick="window.furnitureViewer.toggleView()">üìã See Track List</button>
            </div>
        </div>

        <!-- Simplified Mobile Info Panel -->
        <div id="mobile-info-panel">
            <h3 id="mobile-furniture-info">Loading...</h3>
            <div id="mobile-import-container"></div>
            <div class="mobile-download-section">
                <p>Don't have FirstTapsMV3D?</p>
                <a href="https://play.google.com/store/apps/details?id=com.firsttaps.firsttapsmv3d&pcampaignid=web_share" 
                   class="mobile-download-link primary" 
                   target="_blank">
                    üíö Google Play
                </a>
                <a href="https://www.firsttaps.com" 
                   class="mobile-download-link" 
                   target="_blank">
                    üåê FirstTaps.com
                </a>
            </div>
        </div>

        <div id="track-list-view">
            <button class="back-to-3d-btn" onclick="window.furnitureViewer.toggleView()">‚Üê Back to 3D View</button>
            <h2 id="track-list-title">Track List</h2>
            <div id="track-list-items"></div>
        </div>

        <div id="playlist" style="display: none;">
            <h2>Playlist</h2>
            <div id="playlist-items"></div>
        </div>

        <div id="controls" style="display: none;">
            <div id="direction-pad">
                <button disabled></button>
                <button id="btn-up" title="Move Up">‚ñ≤</button>
                <button disabled></button>
                <button id="btn-left" title="Move Left">‚óÑ</button>
                <button disabled></button>
                <button id="btn-right" title="Move Right">‚ñ∫</button>
                <button disabled></button>
                <button id="btn-down" title="Move Down">‚ñº</button>
                <button disabled></button>
            </div>
            
            <div class="zoom-control">
                <label>Zoom</label>
                <input type="range" id="zoom-slider" min="5" max="50" value="25" orient="vertical">
            </div>
        </div>this.cameraTarget = new THREE.Vector3(0, 0, 0);
                this.cameraDistance = 20;
                
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- LZ-String for decompression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

    <script>
        /**
         * Link Title Label Manager for Viewer
         * Creates text sprites above objects matching app's style
         */
        class LinkTitleManager {
            constructor(scene, THREE) {
                this.scene = scene;
                this.THREE = THREE;
                this.labels = new Map(); // objectUUID -> labelSprite
                console.log('üìù LinkTitleManager initialized for viewer');
            }

            /**
             * Create label sprite for an object
             * @param {THREE.Object3D} object - The object to label
             * @param {string} title - The title text (already truncated to 14 chars)
             */
            createLabel(object, title) {
                if (!title || title.trim() === '') return null;

                try {
                    // Create canvas for text
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    const fontSize = 32;
                    const padding = 8;
                    ctx.font = `bold ${fontSize}px Arial, sans-serif`;
                    const textMetrics = ctx.measureText(title);
                    const textWidth = textMetrics.width;
                    
                    canvas.width = textWidth + padding * 2;
                    canvas.height = fontSize + padding * 2;
                    
                    // Draw background (black with transparency)
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw text (white)
                    ctx.font = `bold ${fontSize}px Arial, sans-serif`;
                    ctx.fillStyle = '#ffffff';
                    ctx.textBaseline = 'top';
                    ctx.fillText(title, padding, padding);
                    
                    // Create texture
                    const texture = new this.THREE.CanvasTexture(canvas);
                    texture.minFilter = this.THREE.LinearFilter;
                    texture.magFilter = this.THREE.LinearFilter;
                    
                    // Create sprite
                    const material = new this.THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 0.9,
                        depthTest: false, // Always visible on top
                        depthWrite: false
                    });
                    
                    const sprite = new this.THREE.Sprite(material);
                    
                    // Scale sprite (0.8 height in world units)
                    const aspectRatio = canvas.width / canvas.height;
                    const spriteHeight = 0.8;
                    sprite.scale.set(spriteHeight * aspectRatio, spriteHeight, 1);
                    
                    // Position above object
                    this.positionLabel(sprite, object);
                    
                    // Add to scene
                    this.scene.add(sprite);
                    
                    // Store reference
                    this.labels.set(object.uuid, sprite);
                    sprite.userData.labelText = title;
                    sprite.userData.linkObjectUUID = object.uuid;
                    
                    console.log(`üìù Created label "${title}" for object ${object.uuid}`);
                    return sprite;
                    
                } catch (error) {
                    console.error('‚ùå Error creating label:', error);
                    return null;
                }
            }

            /**
             * Position label above object
             * @param {THREE.Sprite} sprite - Label sprite
             * @param {THREE.Object3D} object - Object to position above
             */
            positionLabel(sprite, object) {
                // Get object height (furniture objects are typically 3.5 units tall)
                const objectHeight = object.geometry?.parameters?.height || 3.5;
                
                // Update world matrix
                if (object.parent) {
                    object.updateMatrixWorld(true);
                }
                
                // Get world position
                const worldPos = new this.THREE.Vector3();
                object.getWorldPosition(worldPos);
                
                // Position above object (height/2 + 0.6 offset)
                worldPos.y += (objectHeight / 2 + 0.6);
                sprite.position.copy(worldPos);
            }

            /**
             * Update all label positions (call in animation loop if objects move)
             */
            updateLabelPositions() {
                this.labels.forEach((sprite, objectUUID) => {
                    const object = this.scene.getObjectByProperty('uuid', objectUUID);
                    if (object) {
                        this.positionLabel(sprite, object);
                    }
                });
            }

            /**
             * Remove all labels
             */
            removeAllLabels() {
                this.labels.forEach(sprite => {
                    if (sprite.material.map) {
                        sprite.material.map.dispose();
                    }
                    sprite.material.dispose();
                    sprite.geometry.dispose();
                    this.scene.remove(sprite);
                });
                this.labels.clear();
                console.log('üìù Removed all labels');
            }
        }

        // Viewer Application
        class FurnitureViewer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.furniture = null;
                this.objects = [];
                this.currentPlayingIndex = -1;
                this.cameraTarget = new THREE.Vector3(0, 2, 0); // Center on furniture at height 2
                this.cameraDistance = 18; // Zoomed in view
                this.isRotating = false;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.pasteId = null; // Store paste ID for import button
                this.backgroundObjects = []; // Store background objects for cleanup
                this.hoveredObject = null; // Track hovered object for glow effect
                this.isDragging = false; // Track drag state for rotation
                this.dragStartX = 0;
                this.dragStartRotation = 0;
                this.rotationVelocity = 0;
                this.lastDragX = 0;
                this.lastDragTime = 0;
                this.touchDistance = 0; // For pinch-to-zoom
                this.labelManager = null; // For title labels
                
                this.init();
            }

            async init() {
                try {
                    // Initialize Three.js scene first
                    this.initThreeJS();
                    
                    // Extract data from URL
                    const shareData = await this.extractShareData();
                    
                    // Load furniture and objects
                    await this.loadFurniture(shareData);
                    
                    // Setup UI
                    this.setupUI(shareData);
                    
                    // Setup camera controls
                    this.setupCameraControls();
                    
                    // Start render loop
                    this.animate();
                    
                    // Play cinematic intro animation
                    this.playCinematicIntro(() => {
                        // Hide loading after intro - CSS controls which panels show
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('playlist').style.display = 'block';
                        document.getElementById('controls').style.display = 'flex';
                        // Let CSS media queries decide which info panel to show
                    });
                    
                } catch (error) {
                    this.showError(error.message);
                }
            }

            // Helper function to fetch with CORS proxy fallbacks
            async fetchWithProxy(url, pasteServiceName) {
                const proxies = [
                    // Try direct fetch first (works for some services)
                    { url: url, name: 'direct' },
                    // Primary CORS proxy
                    { url: `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`, name: 'allorigins' },
                    // Backup CORS proxy
                    { url: `https://corsproxy.io/?${encodeURIComponent(url)}`, name: 'corsproxy' },
                    // Another backup - thingproxy
                    { url: `https://thingproxy.freeboard.io/fetch/${url}`, name: 'thingproxy' }
                ];

                let lastError = null;
                
                for (const proxy of proxies) {
                    try {
                        console.log(`üîó Trying ${proxy.name} for ${pasteServiceName}:`, proxy.url);
                        
                        // Create AbortController for timeout
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
                        
                        const response = await fetch(proxy.url, {
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (response.ok) {
                            console.log(`‚úÖ Success with ${proxy.name}`);
                            return response;
                        }
                        
                        console.log(`‚ùå ${proxy.name} returned status ${response.status}`);
                        lastError = new Error(`HTTP ${response.status}`);
                    } catch (error) {
                        // Handle timeout and network errors
                        const errorMsg = error.name === 'AbortError' ? 'timeout' : error.message;
                        console.log(`‚ùå ${proxy.name} failed: ${errorMsg}`);
                        lastError = error;
                    }
                }
                
                // All proxies failed
                throw new Error(`Failed to fetch from ${pasteServiceName}. Tried multiple methods. ${lastError?.message || 'Network error'}. Please check your internet connection or try a different share link.`);
            }

            async extractShareData() {
                console.log('üì• Starting data extraction...');
                console.log('üîç Current URL:', window.location.href);
                console.log('üîç Search params:', window.location.search);
                console.log('üîç Hash:', window.location.hash);
                
                const urlParams = new URLSearchParams(window.location.search);
                
                let furnitureData;
                let pasteId = null;
                let pasteService = null;
                
                // Check for paste ID in query params
                if (urlParams.has('gist')) {
                    pasteId = urlParams.get('gist');
                    pasteService = 'gist';
                } else if (urlParams.has('hastebin')) {
                    pasteId = urlParams.get('hastebin');
                    pasteService = 'hastebin';
                } else if (urlParams.has('ixio')) {
                    pasteId = urlParams.get('ixio');
                    pasteService = 'ixio';
                } else if (urlParams.has('paste')) {
                    pasteId = urlParams.get('paste');
                    pasteService = 'paste';
                } else if (urlParams.has('rentry')) {
                    pasteId = urlParams.get('rentry');
                    pasteService = 'rentry';
                } else if (urlParams.has('pastesio')) {
                    pasteId = urlParams.get('pastesio');
                    pasteService = 'pastesio';
                } else if (urlParams.has('pastegg')) {
                    pasteId = urlParams.get('pastegg');
                    pasteService = 'pastegg';
                } else if (urlParams.has('pasters')) {
                    pasteId = urlParams.get('pasters');
                    pasteService = 'pasters';
                } else if (urlParams.has('termbin')) {
                    pasteId = urlParams.get('termbin');
                    pasteService = 'termbin';
                } else if (urlParams.has('dpaste')) {
                    pasteId = urlParams.get('dpaste');
                    pasteService = 'dpaste';
                } else if (urlParams.has('ox0st')) {
                    pasteId = urlParams.get('ox0st');
                    pasteService = 'ox0st';
                }
                // Also check hash parameters
                else if (window.location.hash) {
                    const hash = window.location.hash.substring(1); // Remove #
                    const hashParams = new URLSearchParams(hash);
                    if (hashParams.has('gist')) {
                        pasteId = hashParams.get('gist');
                        pasteService = 'gist';
                    } else if (hashParams.has('hastebin')) {
                        pasteId = hashParams.get('hastebin');
                        pasteService = 'hastebin';
                    } else if (hashParams.has('ixio')) {
                        pasteId = hashParams.get('ixio');
                        pasteService = 'ixio';
                    } else if (hashParams.has('paste')) {
                        pasteId = hashParams.get('paste');
                        pasteService = 'paste';
                    } else if (hashParams.has('rentry')) {
                        pasteId = hashParams.get('rentry');
                        pasteService = 'rentry';
                    } else if (hashParams.has('pastesio')) {
                        pasteId = hashParams.get('pastesio');
                        pasteService = 'pastesio';
                    } else if (hashParams.has('pastegg')) {
                        pasteId = hashParams.get('pastegg');
                        pasteService = 'pastegg';
                    } else if (hashParams.has('pasters')) {
                        pasteId = hashParams.get('pasters');
                        pasteService = 'pasters';
                    } else if (hashParams.has('termbin')) {
                        pasteId = hashParams.get('termbin');
                        pasteService = 'termbin';
                    } else if (hashParams.has('dpaste')) {
                        pasteId = hashParams.get('dpaste');
                        pasteService = 'dpaste';
                    } else if (hashParams.has('ox0st')) {
                        pasteId = hashParams.get('ox0st');
                        pasteService = 'ox0st';
                    }
                }
                
                if (pasteId && pasteService) {
                    this.pasteId = pasteId; // Store for import button
                    
                    // Fetch from appropriate service
                    let response;
                    if (pasteService === 'gist') {
                        console.log('üì• Loading from GitHub Gist:', this.pasteId);
                        // GitHub Gist API - direct fetch, no CORS issues
                        response = await fetch(`https://api.github.com/gists/${this.pasteId}`);
                        if (!response.ok) throw new Error('Failed to fetch from GitHub Gist');
                        
                        const gistData = await response.json();
                        console.log('üì¶ Gist loaded:', gistData);
                        
                        // Get the first file from the gist
                        const files = gistData.files;
                        const firstFile = Object.values(files)[0];
                        if (!firstFile) throw new Error('No files found in Gist');
                        
                        let rawData = firstFile.content.trim();
                        console.log('üì¶ Raw data from Gist (first 100 chars):', rawData.substring(0, 100));
                        
                        // Clean whitespace
                        const originalLength = rawData.length;
                        furnitureData = rawData.replace(/\s+/g, '');
                        if (furnitureData.length !== originalLength) {
                            console.log(`üßπ Cleaned data: ${originalLength} ‚Üí ${furnitureData.length} chars`);
                        }
                        
                        // Decompress with LZ-String
                        console.log('üóúÔ∏è Decompressing with LZ-String...');
                        const jsonString = LZString.decompressFromEncodedURIComponent(furnitureData);
                        if (!jsonString) {
                            throw new Error('Failed to decompress data. The share link may be corrupted.');
                        }
                        console.log('‚úÖ Data decompressed successfully');
                        const data = JSON.parse(jsonString);
                        console.log('‚úÖ Furniture data loaded:', data);
                        return data;
                    } else if (pasteService === 'hastebin') {
                        console.log('üì• Loading from Hastebin:', this.pasteId);
                        // Hastebin raw endpoint - direct fetch, CORS enabled
                        response = await fetch(`https://hastebin.com/raw/${this.pasteId}`);
                        if (!response.ok) throw new Error('Failed to fetch from Hastebin');
                        
                        let rawData = await response.text();
                        console.log('üì¶ Raw data from Hastebin (first 100 chars):', rawData.substring(0, 100));
                        
                        // Clean whitespace
                        const originalLength = rawData.length;
                        furnitureData = rawData.replace(/\s+/g, '');
                        if (furnitureData.length !== originalLength) {
                            console.log(`üßπ Cleaned data: ${originalLength} ‚Üí ${furnitureData.length} chars`);
                        }
                        
                        // Decompress with LZ-String
                        console.log('üóúÔ∏è Decompressing with LZ-String...');
                        const jsonString = LZString.decompressFromEncodedURIComponent(furnitureData);
                        if (!jsonString) {
                            throw new Error('Failed to decompress data. The share link may be corrupted.');
                        }
                        console.log('‚úÖ Data decompressed successfully');
                        const data = JSON.parse(jsonString);
                        console.log('‚úÖ Furniture data loaded:', data);
                        return data;
                    } else if (pasteService === 'ixio') {
                        console.log('üì• Loading from ix.io:', this.pasteId);
                        // ix.io direct fetch
                        response = await fetch(`http://ix.io/${this.pasteId}`);
                        if (!response.ok) throw new Error('Failed to fetch from ix.io');
                    } else if (pasteService === 'paste') {
                        console.log('üì• Loading from dpaste.com:', this.pasteId);
                        // dpaste.com with .txt extension - direct fetch
                        response = await fetch(`https://dpaste.com/${this.pasteId}.txt`);
                        if (!response.ok) throw new Error('Failed to fetch from dpaste.com');
                    } else if (pasteService === 'rentry') {
                        console.log('üì• Loading from rentry.co:', this.pasteId);
                        // rentry.co requires /raw endpoint to get plain text
                        response = await fetch(`https://rentry.co/${this.pasteId}/raw`, {
                            headers: {
                                'Accept': 'text/plain, */*'
                            }
                        });
                        if (!response.ok) throw new Error('Failed to fetch from rentry.co');
                    } else if (pasteService === 'pastesio') {
                        console.log('üì• Loading from pastes.io:', this.pasteId);
                        // pastes.io supports CORS - direct fetch
                        response = await fetch(`https://pastes.io/raw/${this.pasteId}`);
                        if (!response.ok) throw new Error('Failed to fetch from pastes.io');
                    } else if (pasteService === 'pastegg') {
                        console.log('üì• Loading from paste.gg:', this.pasteId);
                        // paste.gg has a proper API endpoint that returns JSON
                        response = await fetch(`https://api.paste.gg/v1/pastes/${this.pasteId}`);
                        if (!response.ok) throw new Error('Failed to fetch from paste.gg');
                        
                        // Parse paste.gg JSON response
                        const pasteData = await response.json();
                        if (pasteData.status === 'success' && pasteData.result?.files?.[0]?.content?.value) {
                            let rawData = pasteData.result.files[0].content.value;
                            console.log('üì¶ Extracted data from paste.gg JSON');
                            
                            // Check if we got HTML instead of data (service error)
                            if (rawData.startsWith('<!DOCTYPE') || rawData.startsWith('<html')) {
                                throw new Error(`Paste service returned HTML error page. The paste may not exist, may have expired, or the service may be having issues. Try generating a new share link.`);
                            }
                            
                            // Clean whitespace
                            const originalLength = rawData.length;
                            furnitureData = rawData.replace(/\s+/g, '');
                            if (furnitureData.length !== originalLength) {
                                console.log(`üßπ Cleaned data: ${originalLength} ‚Üí ${furnitureData.length} chars`);
                            }
                            
                            // Decompress with LZ-String
                            console.log('üóúÔ∏è Decompressing with LZ-String...');
                            const jsonString = LZString.decompressFromEncodedURIComponent(furnitureData);
                            if (!jsonString) {
                                throw new Error('Failed to decompress data. The share link may be corrupted.');
                            }
                            console.log('‚úÖ Data decompressed successfully');
                            const data = JSON.parse(jsonString);
                            console.log('‚úÖ Furniture data loaded:', data);
                            return data;
                        } else {
                            throw new Error('Invalid paste.gg response structure');
                        }
                    } else if (pasteService === 'pasters') {
                        console.log('üì• Loading from paste.rs:', this.pasteId);
                        response = await this.fetchWithProxy(`https://paste.rs/${this.pasteId}`, 'paste.rs');
                    } else if (pasteService === 'termbin') {
                        console.log('üì• Loading from termbin.com:', this.pasteId);
                        response = await this.fetchWithProxy(`https://termbin.com/${this.pasteId}`, 'termbin.com');
                    } else if (pasteService === 'dpaste') {
                        console.log('üì• Loading from dpaste.com:', this.pasteId);
                        response = await this.fetchWithProxy(`https://dpaste.com/${this.pasteId}.txt`, 'dpaste.com');
                    } else if (pasteService === 'ox0st') {
                        console.log('üì• Loading from 0x0.st:', this.pasteId);
                        response = await this.fetchWithProxy(`https://0x0.st/${this.pasteId}`, '0x0.st');
                    }
                    
                    let rawData = (await response.text()).trim();
                    console.log('üì¶ Raw data (first 100 chars):', rawData.substring(0, 100));
                    
                    // Check if we got HTML instead of data (service error)
                    const dataLower = rawData.toLowerCase();
                    if (dataLower.startsWith('<!doctype') || dataLower.startsWith('<html') || dataLower.includes('<head>') || dataLower.includes('<title>')) {
                        console.error('‚ùå Received HTML error page instead of paste data');
                        throw new Error(`The paste does not exist or has expired. Please generate a new share link from FirstTapsMV3D app. (Service: ${pasteService})`);
                    }
                    
                    // Validate data looks like compressed LZ-String (should not be empty and should have valid characters)
                    if (!rawData || rawData.length < 10) {
                        throw new Error(`Paste data is too short or empty. Please generate a new share link.`);
                    }
                    
                    // Clean whitespace
                    const originalLength = rawData.length;
                    furnitureData = rawData.replace(/\s+/g, '');
                    if (furnitureData.length !== originalLength) {
                        console.log(`üßπ Cleaned data: ${originalLength} ‚Üí ${furnitureData.length} chars`);
                    }
                } else {
                    throw new Error('No paste ID found in URL. Please use a valid share link.');
                }
                
                // Decompress with LZ-String
                console.log('üóúÔ∏è Decompressing with LZ-String...');
                const jsonString = LZString.decompressFromEncodedURIComponent(furnitureData);
                
                if (!jsonString) {
                    throw new Error('Failed to decompress data. The share link may be corrupted.');
                }
                
                console.log('‚úÖ Data decompressed successfully');
                console.log('üì¶ Decompressed length:', jsonString.length, 'chars');
                
                // Parse JSON
                const data = JSON.parse(jsonString);
                console.log('‚úÖ Furniture data loaded:', data);
                
                return data;
            }

            initThreeJS() {
                const container = document.getElementById('canvas-container');
                
                // Scene
                this.scene = new THREE.Scene();
                // Default background (will be overridden by world theme)
                this.scene.background = new THREE.Color(0x1a1a2e);
                
                // Initialize label manager
                this.labelManager = new LinkTitleManager(this.scene, THREE);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 5, 25); // Lower and further back
                this.camera.lookAt(0, 2, 0); // Look at furniture center
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(this.renderer.domElement);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7.5);
                this.scene.add(directionalLight);
                
                // Double-tap detection for objects only (furniture uses drag)
                let lastTapTime = 0;
                this.renderer.domElement.addEventListener('click', (e) => {
                    const currentTime = Date.now();
                    const tapGap = currentTime - lastTapTime;
                    
                    if (tapGap < 300 && tapGap > 0) {
                        // Double tap detected - check what was clicked
                        console.log('üîÑ Double-tap detected');
                        
                        // Calculate mouse position
                        const rect = this.renderer.domElement.getBoundingClientRect();
                        this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                        this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                        
                        // Raycast to detect what was clicked
                        this.raycaster.setFromCamera(this.mouse, this.camera);
                        const intersects = this.raycaster.intersectObjects(this.objects, false);
                        
                        if (intersects.length > 0) {
                            // Clicked on an object - open its link
                            const clickedObject = intersects[0].object;
                            if (clickedObject.userData && clickedObject.userData.url && !clickedObject.userData.isLocalMedia) {
                                console.log('üîó Opening object link:', clickedObject.userData.url);
                                window.open(clickedObject.userData.url, '_blank');
                            }
                        }
                    }
                    
                    lastTapTime = currentTime;
                });
                
                // Swipe/drag to rotate furniture
                this.setupDragRotation();
                
                // Pinch-to-zoom for mobile
                this.setupPinchZoom();
                
                // Track mouse position for hover effects
                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                });
                
                // Window resize with debouncing
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => this.onWindowResize(), 100);
                });
                
                // Handle orientation changes with robust layout fixing
                let orientationTimeout;
                const handleOrientationChange = () => {
                    // Clear any pending orientation change
                    clearTimeout(orientationTimeout);
                    
                    // Add orientation change class to trigger smooth transitions
                    document.body.classList.add('orientation-change');
                    
                    orientationTimeout = setTimeout(() => {
                        // Resize Three.js renderer
                        this.onWindowResize();
                        
                        // Clear any inline styles that might have been set
                        const playlist = document.getElementById('playlist');
                        const controls = document.getElementById('controls');
                        const infoPanel = document.getElementById('info-panel');
                        const mobileInfoPanel = document.getElementById('mobile-info-panel');
                        
                        // Let CSS media queries handle panel visibility completely
                        // Don't use JavaScript to toggle panels - CSS with orientation detection works better
                        if (infoPanel) {
                            infoPanel.classList.remove('hidden-by-js');
                        }
                        if (mobileInfoPanel) {
                            mobileInfoPanel.classList.remove('hidden-by-js');
                        }
                        
                        // Remove any conflicting inline styles to let CSS take over
                        if (playlist) {
                            playlist.style.removeProperty('position');
                            playlist.style.removeProperty('transform');
                            playlist.offsetHeight; // Force reflow
                        }
                        
                        if (controls) {
                            controls.style.removeProperty('position');
                            controls.style.removeProperty('transform');
                            controls.offsetHeight; // Force reflow
                        }
                        
                        if (infoPanel) {
                            infoPanel.offsetHeight; // Force reflow
                        }
                        
                        // Remove orientation change class after transitions complete
                        requestAnimationFrame(() => {
                            setTimeout(() => {
                                document.body.classList.remove('orientation-change');
                            }, 300);
                        });
                    }, 200);
                };
                
                // Listen for orientation change events
                window.addEventListener('orientationchange', handleOrientationChange);
                window.addEventListener('resize', handleOrientationChange);
                
                // Also listen for screen orientation API if available
                if (screen.orientation) {
                    screen.orientation.addEventListener('change', handleOrientationChange);
                }
                
                console.log('‚úÖ Three.js initialized');
            }
            
            setWorldBackground(worldData) {
                const worldType = worldData.type || 'green-plane';
                console.log(`üåç Setting world background: ${worldType}`);
                
                // Remove any existing background objects
                if (this.backgroundObjects) {
                    this.backgroundObjects.forEach(obj => {
                        if (obj.parent) obj.parent.remove(obj);
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) obj.material.dispose();
                    });
                }
                this.backgroundObjects = [];
                
                switch(worldType) {
                    case 'space':
                        this.createSpaceBackground();
                        break;
                    case 'ocean':
                        this.createOceanBackground();
                        break;
                    case 'forest':
                        this.createForestBackground();
                        break;
                    case 'dazzle':
                        this.createDazzleBackground();
                        break;
                    case 'cave':
                        this.createCaveBackground();
                        break;
                    case 'christmas':
                        this.createChristmasBackground();
                        break;
                    case 'desert-oasis':
                        this.createDesertBackground();
                        break;
                    case 'tropical-paradise':
                        this.createTropicalBackground();
                        break;
                    case 'flower-wonderland':
                        this.createFlowerBackground();
                        break;
                    case 'record-store':
                        this.createRecordStoreBackground();
                        break;
                    case 'music-festival':
                        this.createMusicFestivalBackground();
                        break;
                    case 'future-car-gallery':
                        this.createCarGalleryBackground();
                        break;
                    case 'modern-gallery-clean':
                        this.createModernGalleryCleanBackground();
                        break;
                    case 'modern-gallery-dark':
                        this.createModernGalleryDarkBackground();
                        break;
                    case 'modern-gallery-warm':
                        this.createModernGalleryWarmBackground();
                        break;
                    case 'green-plane':
                    default:
                        this.createGreenPlaneBackground();
                        break;
                }
            }
            
            createGreenPlaneBackground() {
                // Sky blue background
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0xcccccc, 100, 500);
                
                // Add ground plane
                const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3a7d44,
                    roughness: 0.9,
                    metalness: 0.1
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -5;
                ground.receiveShadow = true;
                this.scene.add(ground);
                this.backgroundObjects.push(ground);
                
                // Add simple trees in the background
                const treeCount = 20;
                for (let i = 0; i < treeCount; i++) {
                    const angle = (i / treeCount) * Math.PI * 2;
                    const distance = 80 + Math.random() * 100;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    // Tree trunk
                    const trunkGeometry = new THREE.CylinderGeometry(1.5, 2, 15, 8);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x4d2f1a });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(x, 2.5, z);
                    trunk.castShadow = true;
                    this.scene.add(trunk);
                    this.backgroundObjects.push(trunk);
                    
                    // Tree foliage
                    const foliageGeometry = new THREE.SphereGeometry(8, 8, 8);
                    const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5016 });
                    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage.position.set(x, 15, z);
                    foliage.castShadow = true;
                    this.scene.add(foliage);
                    this.backgroundObjects.push(foliage);
                }
                
                // Add simple clouds
                const cloudCount = 8;
                for (let i = 0; i < cloudCount; i++) {
                    const x = (Math.random() - 0.5) * 400;
                    const y = 40 + Math.random() * 30;
                    const z = (Math.random() - 0.5) * 400;
                    
                    // Create cloud from spheres
                    const cloudGroup = new THREE.Group();
                    const puffCount = 3 + Math.floor(Math.random() * 3);
                    for (let j = 0; j < puffCount; j++) {
                        const puffGeometry = new THREE.SphereGeometry(4 + Math.random() * 3, 8, 8);
                        const puffMaterial = new THREE.MeshBasicMaterial({
                            color: 0xffffff,
                            transparent: true,
                            opacity: 0.8
                        });
                        const puff = new THREE.Mesh(puffGeometry, puffMaterial);
                        puff.position.set(
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 6
                        );
                        cloudGroup.add(puff);
                    }
                    cloudGroup.position.set(x, y, z);
                    this.scene.add(cloudGroup);
                    this.backgroundObjects.push(cloudGroup);
                }
            }
            
            createSpaceBackground() {
                // Deep space black
                this.scene.background = new THREE.Color(0x000022);
                
                // Create starfield
                const starCount = 800;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(starCount * 3);
                const colors = new Float32Array(starCount * 3);
                
                for (let i = 0; i < starCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 400;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 400;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 400;
                    
                    const brightness = 0.7 + Math.random() * 0.3;
                    colors[i * 3] = brightness;
                    colors[i * 3 + 1] = brightness;
                    colors[i * 3 + 2] = brightness;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9
                });
                
                const stars = new THREE.Points(geometry, material);
                this.scene.add(stars);
                this.backgroundObjects.push(stars);
            }
            
            createOceanBackground() {
                // Deep ocean blue
                this.scene.background = new THREE.Color(0x006994);
                this.scene.fog = new THREE.Fog(0x006994, 50, 300);
                
                // Add ocean floor
                const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a4d5c,
                    roughness: 0.95,
                    metalness: 0.05
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                this.scene.add(floor);
                this.backgroundObjects.push(floor);
                
                // Add floating particles for underwater atmosphere
                const particleCount = 200;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 300;
                    positions[i * 3 + 1] = Math.random() * 100;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 300;
                    
                    // Light blue bubbles/particles
                    colors[i * 3] = 0.3 + Math.random() * 0.3;
                    colors[i * 3 + 1] = 0.7 + Math.random() * 0.3;
                    colors[i * 3 + 2] = 1.0;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.backgroundObjects.push(particles);
                
                // Add coral/rock formations
                const rockCount = 15;
                for (let i = 0; i < rockCount; i++) {
                    const angle = (i / rockCount) * Math.PI * 2;
                    const distance = 100 + Math.random() * 80;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    const height = 5 + Math.random() * 10;
                    const rockGeometry = new THREE.ConeGeometry(3 + Math.random() * 2, height, 6);
                    const rockMaterial = new THREE.MeshStandardMaterial({
                        color: Math.random() > 0.5 ? 0x2d5555 : 0xcc5577,
                        roughness: 0.8
                    });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(x, -5 + height / 2, z);
                    rock.rotation.y = Math.random() * Math.PI;
                    this.scene.add(rock);
                    this.backgroundObjects.push(rock);
                }
            }
            
            createForestBackground() {
                // Forest green with mist
                this.scene.background = new THREE.Color(0x2d5016);
                this.scene.fog = new THREE.Fog(0x3a6020, 40, 250);
                
                // Add forest floor
                const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3a4d2a,
                    roughness: 0.95,
                    metalness: 0.05
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                this.scene.add(floor);
                this.backgroundObjects.push(floor);
                
                // Add dense trees
                const treeCount = 30;
                for (let i = 0; i < treeCount; i++) {
                    const angle = (i / treeCount) * Math.PI * 2;
                    const distance = 60 + Math.random() * 100;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    // Tree trunk
                    const trunkHeight = 12 + Math.random() * 8;
                    const trunkGeometry = new THREE.CylinderGeometry(1.2, 1.8, trunkHeight, 6);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(x, -5 + trunkHeight / 2, z);
                    this.scene.add(trunk);
                    this.backgroundObjects.push(trunk);
                    
                    // Tree foliage - denser and darker
                    const foliageGeometry = new THREE.SphereGeometry(6 + Math.random() * 3, 8, 8);
                    const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x1a3d0f });
                    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage.position.set(x, -5 + trunkHeight + 3, z);
                    this.scene.add(foliage);
                    this.backgroundObjects.push(foliage);
                }
                
                // Add mist particles
                const particleCount = 150;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 250;
                    positions[i * 3 + 1] = Math.random() * 50;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 250;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 4,
                    color: 0x4d6040,
                    transparent: true,
                    opacity: 0.3
                });
                
                const mist = new THREE.Points(geometry, material);
                this.scene.add(mist);
                this.backgroundObjects.push(mist);
            }
            
            createDazzleBackground() {
                // Warm pink/purple gradient
                this.scene.background = new THREE.Color(0xE6B8E6);
                this.scene.fog = new THREE.Fog(0xE6B8E6, 60, 300);
                
                // Add glossy floor
                const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD8A8D8,
                    roughness: 0.2,
                    metalness: 0.7
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                this.scene.add(floor);
                this.backgroundObjects.push(floor);
                
                // Add floating disco balls/orbs
                const orbCount = 15;
                for (let i = 0; i < orbCount; i++) {
                    const angle = (i / orbCount) * Math.PI * 2;
                    const distance = 80 + Math.random() * 80;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    const y = 10 + Math.random() * 30;
                    
                    const orbGeometry = new THREE.SphereGeometry(3 + Math.random() * 2, 16, 16);
                    const orbMaterial = new THREE.MeshStandardMaterial({
                        color: Math.random() > 0.5 ? 0xFF00FF : 0xFF1493,
                        emissive: Math.random() > 0.5 ? 0xAA00AA : 0xAA0044,
                        emissiveIntensity: 0.6,
                        roughness: 0.1,
                        metalness: 0.9
                    });
                    const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                    orb.position.set(x, y, z);
                    this.scene.add(orb);
                    this.backgroundObjects.push(orb);
                }
                
                // Add sparkle/glitter particles
                const particleCount = 400;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 350;
                    positions[i * 3 + 1] = Math.random() * 120;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 350;
                    
                    // Pink, purple, magenta sparkles
                    const colorType = Math.random();
                    if (colorType < 0.33) {
                        colors[i * 3] = 1.0;
                        colors[i * 3 + 1] = 0.1;
                        colors[i * 3 + 2] = 0.9;
                    } else if (colorType < 0.66) {
                        colors[i * 3] = 0.9;
                        colors[i * 3 + 1] = 0.1;
                        colors[i * 3 + 2] = 0.6;
                    } else {
                        colors[i * 3] = 1.0;
                        colors[i * 3 + 1] = 0.7;
                        colors[i * 3 + 2] = 0.9;
                    }
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.backgroundObjects.push(particles);
            }
            
            createCaveBackground() {
                // Dark cave atmosphere
                this.scene.background = new THREE.Color(0x1a1a1a);
                this.scene.fog = new THREE.Fog(0x0a0a0a, 20, 150);
                
                // Add cave floor (rough rock)
                const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3a3a3a,
                    roughness: 1,
                    metalness: 0
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                this.scene.add(floor);
                this.backgroundObjects.push(floor);
                
                // Add stalagmites
                const stalagmiteCount = 20;
                for (let i = 0; i < stalagmiteCount; i++) {
                    const angle = (i / stalagmiteCount) * Math.PI * 2;
                    const distance = 60 + Math.random() * 70;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    const height = 8 + Math.random() * 12;
                    const rockGeometry = new THREE.ConeGeometry(2 + Math.random(), height, 6);
                    const rockMaterial = new THREE.MeshStandardMaterial({
                        color: 0x4a4a4a,
                        roughness: 0.95
                    });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(x, -5 + height / 2, z);
                    this.scene.add(rock);
                    this.backgroundObjects.push(rock);
                }
                
                // Add glowing crystal formations
                const crystalCount = 12;
                for (let i = 0; i < crystalCount; i++) {
                    const angle = (i / crystalCount) * Math.PI * 2;
                    const distance = 70 + Math.random() * 50;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    const crystalGeometry = new THREE.OctahedronGeometry(2 + Math.random() * 2);
                    const crystalMaterial = new THREE.MeshStandardMaterial({
                        color: 0x4488ff,
                        emissive: 0x2244aa,
                        emissiveIntensity: 0.5,
                        roughness: 0.1,
                        metalness: 0.8
                    });
                    const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                    crystal.position.set(x, -5 + Math.random() * 3, z);
                    crystal.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    this.scene.add(crystal);
                    this.backgroundObjects.push(crystal);
                }
                
                // Add mysterious glowing particles
                const particleCount = 150;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 200;
                    positions[i * 3 + 1] = Math.random() * 60;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
                    
                    // Blue/purple glow
                    colors[i * 3] = 0.3 + Math.random() * 0.4;
                    colors[i * 3 + 1] = 0.3 + Math.random() * 0.3;
                    colors[i * 3 + 2] = 0.8 + Math.random() * 0.2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.backgroundObjects.push(particles);
            }
            
            createChristmasBackground() {
                // Snowy white/blue
                this.scene.background = new THREE.Color(0xE8F4F8);
                this.scene.fog = new THREE.Fog(0xE8F4F8, 70, 350);
                
                // Add snowy ground
                const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFFFFF,
                    roughness: 0.9,
                    metalness: 0.1
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                this.scene.add(floor);
                this.backgroundObjects.push(floor);
                
                // Add snow-covered pine trees
                const treeCount = 18;
                for (let i = 0; i < treeCount; i++) {
                    const angle = (i / treeCount) * Math.PI * 2;
                    const distance = 90 + Math.random() * 110;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    // Tree trunk
                    const trunkGeometry = new THREE.CylinderGeometry(1, 1.5, 10, 6);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(x, 0, z);
                    this.scene.add(trunk);
                    this.backgroundObjects.push(trunk);
                    
                    // Pine tree layers with snow
                    for (let layer = 0; layer < 4; layer++) {
                        const layerGeometry = new THREE.ConeGeometry(6 - layer * 1.2, 5, 8);
                        const layerMaterial = new THREE.MeshStandardMaterial({ color: 0x1a4d2f });
                        const layerMesh = new THREE.Mesh(layerGeometry, layerMaterial);
                        layerMesh.position.set(x, 8 + layer * 3, z);
                        this.scene.add(layerMesh);
                        this.backgroundObjects.push(layerMesh);
                        
                        // Snow on top
                        const snowGeometry = new THREE.ConeGeometry(6.2 - layer * 1.2, 0.5, 8);
                        const snowMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                        const snow = new THREE.Mesh(snowGeometry, snowMaterial);
                        snow.position.set(x, 10.5 + layer * 3, z);
                        this.scene.add(snow);
                        this.backgroundObjects.push(snow);
                    }
                }
                
                // Add falling snow particles
                const particleCount = 300;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 350;
                    positions[i * 3 + 1] = Math.random() * 150;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 350;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.8
                });
                
                const snowflakes = new THREE.Points(geometry, material);
                this.scene.add(snowflakes);
                this.backgroundObjects.push(snowflakes);
            }
            
            createDesertBackground() {
                // Sandy desert yellow/orange
                this.scene.background = new THREE.Color(0xF4C542);
                this.scene.fog = new THREE.Fog(0xF4C542, 80, 400);
                
                // Add sand floor
                const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0xE4B850,
                    roughness: 0.95,
                    metalness: 0
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                this.scene.add(floor);
                this.backgroundObjects.push(floor);
                
                // Add cacti
                const cactiCount = 12;
                for (let i = 0; i < cactiCount; i++) {
                    const angle = (i / cactiCount) * Math.PI * 2;
                    const distance = 100 + Math.random() * 120;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    const height = 8 + Math.random() * 6;
                    const cactusGeometry = new THREE.CylinderGeometry(1, 1.2, height, 8);
                    const cactusMaterial = new THREE.MeshStandardMaterial({ color: 0x3a5f2f });
                    const cactus = new THREE.Mesh(cactusGeometry, cactusMaterial);
                    cactus.position.set(x, -5 + height / 2, z);
                    this.scene.add(cactus);
                    this.backgroundObjects.push(cactus);
                    
                    // Add arms to some cacti
                    if (Math.random() > 0.5) {
                        const armGeometry = new THREE.CylinderGeometry(0.6, 0.7, 3, 6);
                        const arm = new THREE.Mesh(armGeometry, cactusMaterial);
                        arm.position.set(x + 1.5, -5 + height * 0.6, z);
                        arm.rotation.z = Math.PI / 2;
                        this.scene.add(arm);
                        this.backgroundObjects.push(arm);
                    }
                }
                
                // Add heat shimmer particles
                const particleCount = 100;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 300;
                    positions[i * 3 + 1] = Math.random() * 30;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 300;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 3,
                    color: 0xFFF4D0,
                    transparent: true,
                    opacity: 0.25
                });
                
                const shimmer = new THREE.Points(geometry, material);
                this.scene.add(shimmer);
                this.backgroundObjects.push(shimmer);
            }
            
            createTropicalBackground() {
                // Tropical turquoise
                this.scene.background = new THREE.Color(0x40E0D0);
                this.scene.fog = new THREE.Fog(0x40E0D0, 60, 320);
                
                // Add sandy beach floor
                const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0xF4E4C1,
                    roughness: 0.9,
                    metalness: 0.05
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                this.scene.add(floor);
                this.backgroundObjects.push(floor);
                
                // Add palm trees
                const palmCount = 15;
                for (let i = 0; i < palmCount; i++) {
                    const angle = (i / palmCount) * Math.PI * 2;
                    const distance = 80 + Math.random() * 100;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    // Palm trunk
                    const trunkHeight = 15 + Math.random() * 8;
                    const trunkGeometry = new THREE.CylinderGeometry(0.8, 1, trunkHeight, 6);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B6F47 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(x, -5 + trunkHeight / 2, z);
                    this.scene.add(trunk);
                    this.backgroundObjects.push(trunk);
                    
                    // Palm leaves
                    for (let j = 0; j < 6; j++) {
                        const leafAngle = (j / 6) * Math.PI * 2;
                        const leafGeometry = new THREE.ConeGeometry(0.5, 6, 4);
                        const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                        leaf.position.set(
                            x + Math.cos(leafAngle) * 2,
                            -5 + trunkHeight + 1,
                            z + Math.sin(leafAngle) * 2
                        );
                        leaf.rotation.z = Math.PI / 3;
                        leaf.rotation.y = leafAngle;
                        this.scene.add(leaf);
                        this.backgroundObjects.push(leaf);
                    }
                }
                
                // Add tropical atmosphere particles
                const particleCount = 120;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 300;
                    positions[i * 3 + 1] = Math.random() * 80;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 300;
                    
                    // Turquoise particles
                    colors[i * 3] = 0.25;
                    colors[i * 3 + 1] = 0.88;
                    colors[i * 3 + 2] = 0.82;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.4
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.backgroundObjects.push(particles);
            }
            
            createFlowerBackground() {
                // Soft pastel pink
                this.scene.background = new THREE.Color(0xFFB6C1);
                this.scene.fog = new THREE.Fog(0xFFB6C1, 50, 280);
                
                // Add grass floor
                const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0x7EC850,
                    roughness: 0.95,
                    metalness: 0
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                this.scene.add(floor);
                this.backgroundObjects.push(floor);
                
                // Add flower clusters
                const clusterCount = 25;
                for (let i = 0; i < clusterCount; i++) {
                    const angle = (i / clusterCount) * Math.PI * 2;
                    const distance = 70 + Math.random() * 100;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    // Flower stem
                    const stemGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 6);
                    const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x4d8c3d });
                    const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                    stem.position.set(x, -2.5, z);
                    this.scene.add(stem);
                    this.backgroundObjects.push(stem);
                    
                    // Flower head (multiple petals)
                    const flowerColors = [0xFF69B4, 0xFF1493, 0xFFB6C1, 0xFF6EB4, 0xFFA07A];
                    const flowerColor = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                    
                    for (let p = 0; p < 6; p++) {
                        const petalAngle = (p / 6) * Math.PI * 2;
                        const petalGeometry = new THREE.SphereGeometry(1.2, 8, 8);
                        const petalMaterial = new THREE.MeshStandardMaterial({ color: flowerColor });
                        const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                        petal.scale.set(0.6, 1, 0.3);
                        petal.position.set(
                            x + Math.cos(petalAngle) * 1.5,
                            0.5,
                            z + Math.sin(petalAngle) * 1.5
                        );
                        petal.rotation.z = petalAngle;
                        this.scene.add(petal);
                        this.backgroundObjects.push(petal);
                    }
                    
                    // Flower center
                    const centerGeometry = new THREE.SphereGeometry(0.8, 8, 8);
                    const centerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    center.position.set(x, 0.5, z);
                    this.scene.add(center);
                    this.backgroundObjects.push(center);
                }
                
                // Add floating petals/sparkles
                const particleCount = 200;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 300;
                    positions[i * 3 + 1] = Math.random() * 80;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 300;
                    
                    // Pink/white petals
                    colors[i * 3] = 1.0;
                    colors[i * 3 + 1] = 0.7 + Math.random() * 0.3;
                    colors[i * 3 + 2] = 0.8 + Math.random() * 0.2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.backgroundObjects.push(particles);
            }
            
            createRecordStoreBackground() {
                // Warm amber/brown atmosphere - cozy record store
                this.scene.background = new THREE.Color(0x4A3520);
                this.scene.fog = new THREE.Fog(0x4A3520, 150, 400);
                
                // Add warm ambient particles for atmosphere
                const particleCount = 150;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 200;
                    positions[i * 3 + 1] = Math.random() * 100;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
                    
                    // Warm amber/orange glow particles
                    colors[i * 3] = 1.0;
                    colors[i * 3 + 1] = 0.6 + Math.random() * 0.2;
                    colors[i * 3 + 2] = 0.3;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.4
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.backgroundObjects.push(particles);
            }
            
            createMusicFestivalBackground() {
                // Evening/dusk atmosphere - outdoor concert
                this.scene.background = new THREE.Color(0x1a1a2e);
                this.scene.fog = new THREE.Fog(0x1a1a2e, 100, 500);
                
                // Add colored stage light particles
                const particleCount = 200;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 300;
                    positions[i * 3 + 1] = Math.random() * 150;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 300;
                    
                    // Random stage light colors (pink, cyan, yellow)
                    const colorType = Math.random();
                    if (colorType < 0.33) {
                        // Pink
                        colors[i * 3] = 1.0;
                        colors[i * 3 + 1] = 0.0;
                        colors[i * 3 + 2] = 0.4;
                    } else if (colorType < 0.66) {
                        // Cyan
                        colors[i * 3] = 0.0;
                        colors[i * 3 + 1] = 1.0;
                        colors[i * 3 + 2] = 1.0;
                    } else {
                        // Yellow
                        colors[i * 3] = 1.0;
                        colors[i * 3 + 1] = 1.0;
                        colors[i * 3 + 2] = 0.0;
                    }
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 4,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.5
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.backgroundObjects.push(particles);
            }
            
            createCarGalleryBackground() {
                // Dark tech atmosphere with electric blue accents
                this.scene.background = new THREE.Color(0x0a0a0f);
                this.scene.fog = new THREE.Fog(0x0a0a0f, 80, 350);
                
                // Add electric blue tech particles
                const particleCount = 120;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 250;
                    positions[i * 3 + 1] = Math.random() * 80;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 250;
                    
                    // Electric blue/cyan tech glow
                    colors[i * 3] = 0.0;
                    colors[i * 3 + 1] = 0.7 + Math.random() * 0.3;
                    colors[i * 3 + 2] = 1.0;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.backgroundObjects.push(particles);
            }
            
            createModernGalleryCleanBackground() {
                // Bright, clean white gallery
                this.scene.background = new THREE.Color(0xF5F5F5);
                this.scene.fog = new THREE.Fog(0xF5F5F5, 100, 400);
                
                // Add polished floor
                const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFFFFF,
                    roughness: 0.1,
                    metalness: 0.3
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                this.scene.add(floor);
                this.backgroundObjects.push(floor);
                
                // Add minimalist columns
                const columnCount = 8;
                for (let i = 0; i < columnCount; i++) {
                    const angle = (i / columnCount) * Math.PI * 2;
                    const distance = 120;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    const columnGeometry = new THREE.CylinderGeometry(3, 3, 40, 16);
                    const columnMaterial = new THREE.MeshStandardMaterial({
                        color: 0xFFFFFF,
                        roughness: 0.2,
                        metalness: 0.1
                    });
                    const column = new THREE.Mesh(columnGeometry, columnMaterial);
                    column.position.set(x, 15, z);
                    this.scene.add(column);
                    this.backgroundObjects.push(column);
                }
                
                // Add subtle light particles
                const particleCount = 100;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 250;
                    positions[i * 3 + 1] = Math.random() * 80;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 250;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    color: 0xF0F0F0,
                    transparent: true,
                    opacity: 0.3
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.backgroundObjects.push(particles);
            }
            
            createModernGalleryDarkBackground() {
                // Dark, moody gallery
                this.scene.background = new THREE.Color(0x1a1a1a);
                this.scene.fog = new THREE.Fog(0x1a1a1a, 60, 300);
                
                // Subtle dim spotlights
                const particleCount = 80;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 180;
                    positions[i * 3 + 1] = 30 + Math.random() * 40;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 180;
                    
                    // Dim white/warm spotlight glow
                    const brightness = 0.5 + Math.random() * 0.3;
                    colors[i * 3] = brightness;
                    colors[i * 3 + 1] = brightness * 0.95;
                    colors[i * 3 + 2] = brightness * 0.9;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.4
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.backgroundObjects.push(particles);
            }
            
            createModernGalleryWarmBackground() {
                // Warm beige/brown gallery
                this.scene.background = new THREE.Color(0xE8DCC8);
                this.scene.fog = new THREE.Fog(0xE8DCC8, 90, 380);
                
                // Warm ambient light particles
                const particleCount = 100;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 200;
                    positions[i * 3 + 1] = Math.random() * 90;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
                    
                    // Soft warm glow
                    colors[i * 3] = 1.0;
                    colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
                    colors[i * 3 + 2] = 0.6 + Math.random() * 0.2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.35
                });
                
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.backgroundObjects.push(particles);
            }

            animateFurnitureRotation(targetRotation) {
                if (!this.furniture || this.isRotating) return;
                
                this.isRotating = true;
                const startRotation = this.furniture.rotation.y;
                const duration = 500; // ms
                const startTime = Date.now();
                
                const rotate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function for smooth rotation
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    this.furniture.rotation.y = startRotation + (targetRotation - startRotation) * eased;
                    
                    if (progress < 1) {
                        requestAnimationFrame(rotate);
                    } else {
                        this.isRotating = false;
                    }
                };
                
                rotate();
            }

            playCinematicIntro(callback) {
                // Cinematic intro: zoom in and rotate furniture to show all objects
                if (!this.furniture) {
                    callback();
                    return;
                }
                
                const DURATION = 3000; // 3 seconds
                const startTime = Date.now();
                const startDistance = 60;
                const endDistance = this.cameraDistance;
                const startHeight = 20;
                const endHeight = this.cameraTarget.y + 8;
                const initialRotation = this.furniture.userData.frontFacingRotation || 0;
                const startRotation = initialRotation;
                const endRotation = initialRotation + Math.PI * 2; // Full 360¬∞ rotation
                
                // Allow skipping intro with tap/click
                let skipped = false;
                const skipIntro = () => {
                    skipped = true;
                    this.cameraDistance = endDistance;
                    if (this.furniture) {
                        const finalRotation = this.furniture.userData.frontFacingRotation || 0; this.furniture.rotation.y = finalRotation;
                    }
                    callback();
                };
                
                const onTap = () => {
                    if (!skipped) {
                        skipIntro();
                        this.renderer.domElement.removeEventListener('pointerdown', onTap);
                    }
                };
                
                this.renderer.domElement.addEventListener('pointerdown', onTap, { once: true });
                
                const animateIntro = () => {
                    if (skipped) return;
                    
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / DURATION, 1);
                    
                    // Ease out cubic for smooth deceleration
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    // Animate camera zoom
                    this.cameraDistance = startDistance - (startDistance - endDistance) * eased;
                    
                    // Animate camera height
                    const currentHeight = startHeight - (startHeight - endHeight) * eased;
                    this.camera.position.y = currentHeight;
                    
                    // Rotate furniture to showcase objects
                    if (this.furniture) {
                        this.furniture.rotation.y = startRotation + (endRotation - startRotation) * eased;
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateIntro);
                    } else {
                        // Intro complete - reset to front-facing view
                        if (this.furniture) {
                            const finalRotation = this.furniture.userData.frontFacingRotation || 0; this.furniture.rotation.y = finalRotation;
                        }
                        this.renderer.domElement.removeEventListener('pointerdown', onTap);
                        callback();
                    }
                };
                
                // Start intro animation
                this.cameraDistance = startDistance;
                animateIntro();
            }

            setupDragRotation() {
                const canvas = this.renderer.domElement;
                
                const onPointerDown = (e) => {
                    this.isDragging = true;
                    this.dragStartX = e.clientX || (e.touches && e.touches[0].clientX);
                    this.dragStartRotation = this.furniture ? this.furniture.rotation.y : 0;
                    this.rotationVelocity = 0;
                    this.lastDragX = this.dragStartX;
                    this.lastDragTime = Date.now();
                    canvas.style.cursor = 'grabbing';
                };
                
                const onPointerMove = (e) => {
                    if (!this.isDragging || !this.furniture) return;
                    
                    const currentX = e.clientX || (e.touches && e.touches[0].clientX);
                    const deltaX = currentX - this.dragStartX;
                    const currentTime = Date.now();
                    
                    // Calculate rotation (sensitivity)
                    const rotationAmount = (deltaX / window.innerWidth) * Math.PI * 2;
                    this.furniture.rotation.y = this.dragStartRotation + rotationAmount;
                    
                    // Calculate velocity for momentum
                    const timeDelta = currentTime - this.lastDragTime;
                    if (timeDelta > 0) {
                        this.rotationVelocity = ((currentX - this.lastDragX) / window.innerWidth) * Math.PI * 0.5;
                    }
                    
                    this.lastDragX = currentX;
                    this.lastDragTime = currentTime;
                };
                
                const onPointerUp = () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        canvas.style.cursor = 'grab';
                        
                        // Snap to nearest 45¬∞ if moving slowly
                        if (Math.abs(this.rotationVelocity) < 0.01 && this.furniture) {
                            const currentRotation = this.furniture.rotation.y;
                            const snapAngle = Math.PI / 4; // 45¬∞
                            const snappedRotation = Math.round(currentRotation / snapAngle) * snapAngle;
                            const targetRotation = snappedRotation;
                            
                            // Smooth snap animation
                            const startRotation = currentRotation;
                            const duration = 300;
                            const startTime = Date.now();
                            
                            const snapAnimation = () => {
                                const elapsed = Date.now() - startTime;
                                const progress = Math.min(elapsed / duration, 1);
                                const eased = 1 - Math.pow(1 - progress, 3);
                                
                                if (this.furniture) {
                                    this.furniture.rotation.y = startRotation + (targetRotation - startRotation) * eased;
                                }
                                
                                if (progress < 1) {
                                    requestAnimationFrame(snapAnimation);
                                }
                            };
                            
                            snapAnimation();
                        }
                    }
                };
                
                // Mouse events
                canvas.addEventListener('mousedown', onPointerDown);
                canvas.addEventListener('mousemove', onPointerMove);
                canvas.addEventListener('mouseup', onPointerUp);
                canvas.addEventListener('mouseleave', onPointerUp);
                
                // Touch events
                canvas.addEventListener('touchstart', onPointerDown, { passive: true });
                canvas.addEventListener('touchmove', onPointerMove, { passive: true });
                canvas.addEventListener('touchend', onPointerUp);
                
                canvas.style.cursor = 'grab';
            }

            setupPinchZoom() {
                const canvas = this.renderer.domElement;
                
                const getTouchDistance = (touches) => {
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                };
                
                canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        this.touchDistance = getTouchDistance(e.touches);
                        e.preventDefault();
                    }
                }, { passive: false });
                
                canvas.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2 && this.touchDistance > 0) {
                        const newDistance = getTouchDistance(e.touches);
                        const scale = newDistance / this.touchDistance;
                        
                        // Adjust camera distance (zoom)
                        this.cameraDistance = Math.max(5, Math.min(50, this.cameraDistance / scale));
                        
                        this.touchDistance = newDistance;
                        e.preventDefault();
                    }
                }, { passive: false });
                
                canvas.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) {
                        this.touchDistance = 0;
                    }
                });
            }

            updateObjectHover() {
                // Raycast mouse position to detect hovered objects
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.objects, false);
                
                // Reset previous hovered object
                if (this.hoveredObject && this.hoveredObject !== (intersects[0]?.object)) {
                    // Remove glow from all materials
                    if (Array.isArray(this.hoveredObject.material)) {
                        this.hoveredObject.material.forEach(mat => {
                            mat.emissive.setHex(mat.userData.originalEmissive || 0x000000);
                            mat.emissiveIntensity = mat.userData.originalEmissiveIntensity || 0;
                        });
                    } else {
                        this.hoveredObject.material.emissive.setHex(this.hoveredObject.material.userData.originalEmissive || 0x000000);
                        this.hoveredObject.material.emissiveIntensity = this.hoveredObject.material.userData.originalEmissiveIntensity || 0;
                    }
                    this.hoveredObject = null;
                }
                
                // Apply glow to hovered object
                if (intersects.length > 0) {
                    const hoveredObj = intersects[0].object;
                    if (hoveredObj !== this.hoveredObject) {
                        this.hoveredObject = hoveredObj;
                        
                        // Add glow to all materials
                        if (Array.isArray(hoveredObj.material)) {
                            hoveredObj.material.forEach((mat, index) => {
                                if (!mat.userData.originalEmissive) {
                                    mat.userData.originalEmissive = mat.emissive.getHex();
                                    mat.userData.originalEmissiveIntensity = mat.emissiveIntensity || 0;
                                }
                                // Front face (index 4) glows more
                                if (index === 4) {
                                    mat.emissive.setHex(0x4466ff);
                                    mat.emissiveIntensity = 0.4;
                                } else {
                                    mat.emissive.setHex(0x2244aa);
                                    mat.emissiveIntensity = 0.2;
                                }
                            });
                        } else {
                            if (!hoveredObj.material.userData.originalEmissive) {
                                hoveredObj.material.userData.originalEmissive = hoveredObj.material.emissive.getHex();
                                hoveredObj.material.userData.originalEmissiveIntensity = hoveredObj.material.emissiveIntensity || 0;
                            }
                            hoveredObj.material.emissive.setHex(0x3355cc);
                            hoveredObj.material.emissiveIntensity = 0.3;
                        }
                    }
                }
            }

            async loadFurniture(shareData) {
                const furnitureData = shareData.furniture;
                const objectsData = shareData.objects;
                
                console.log(`ü™ë Loading furniture: ${furnitureData.name} (${furnitureData.type})`);
                
                // Set world background if world data is provided
                if (shareData.world) {
                    this.setWorldBackground(shareData.world);
                }
                
                // Create furniture visual
                this.createFurnitureVisual(furnitureData);
                
                // Create objects
                for (const objData of objectsData) {
                    if (objData.isLocalMedia) {
                        // Create placeholder for local media
                        this.createLocalMediaPlaceholder(objData, furnitureData);
                    } else {
                        // Create shareable web link object
                        await this.createLinkObject(objData, furnitureData);
                    }
                }
                
                console.log(`‚úÖ Loaded ${this.objects.length} objects`);
            }

            createFurnitureVisual(furnitureData) {
                // Create furniture structure based on type
                const group = new THREE.Group();
                const material = new THREE.MeshStandardMaterial({
                    color: this.getStyleColor(furnitureData.style),
                    metalness: 0.3,
                    roughness: 0.7
                });
                
                const type = furnitureData.type;
                console.log('ü™ë Creating furniture type:', type);
                
                switch(type) {
                    case 'bookshelf':
                        this.createBookshelf(group, material);
                        group.position.set(0, 3.5, 0);
                        break;
                    case 'riser':
                        this.createRiser(group, material);
                        group.position.set(0, 0, 0);
                        // Position camera to face front (lowest tier at positive Z)
                        this.cameraDistance = 22;
                        this.cameraTarget.set(0, 1.5, 4);
                        break;
                    case 'gallery_wall':
                        this.createGalleryWall(group, material);
                        group.position.set(0, 3, 0);
                        break;
                    case 'stage_small':
                    case 'stage_large':
                        this.createStage(group, material, type === 'stage_large');
                        group.position.set(0, 1, 0);
                        break;
                    case 'amphitheatre':
                        this.createAmphitheatre(group, material);
                        group.position.set(0, 0, 0);
                        // Zoom out and position camera to show front
                        this.cameraDistance = 40;
                        this.cameraTarget.set(0, 5, 0);
                        break;
                    default:
                        // Fallback to gallery wall
                        this.createGalleryWall(group, material);
                        group.position.set(0, 3, 0);
                }
                
                group.userData = {
                    name: furnitureData.name,
                    type: furnitureData.type
                };
                
                // Rotate riser 180 degrees so lowest tier faces camera
                if (type === 'riser') {
                    group.rotation.y = Math.PI;
                    group.userData.frontFacingRotation = Math.PI; // Keep riser facing forward after animation
                }
                
                // Set front-facing rotation for other furniture types too
                if (!group.userData.frontFacingRotation) {
                    group.userData.frontFacingRotation = 0;
                }
                
                this.scene.add(group);
                this.furniture = group;
            }
            
            createBookshelf(group, material) {
                // Back panel
                const backGeom = new THREE.BoxGeometry(18, 7, 0.2);
                const back = new THREE.Mesh(backGeom, material);
                back.position.set(0, 3.5, -1);
                group.add(back);
                
                // Shelves
                const shelfGeom = new THREE.BoxGeometry(18, 0.3, 2);
                for (let i = 0; i <= 2; i++) {
                    const shelf = new THREE.Mesh(shelfGeom, material);
                    shelf.position.set(0, i * 3.5, 0);
                    group.add(shelf);
                }
            }
            
            createRiser(group, material) {
                // 3 tiered steps
                const tiers = 3;
                const tierHeight = 1.0;
                const tierDepth = 4;
                const width = 24;
                
                for (let i = 0; i < tiers; i++) {
                    const currentHeight = (tiers - i - 1) * tierHeight;
                    const zOffset = tierDepth * (tiers - 1 - i); // Reverse: front (lowest) at positive Z
                    
                    // Platform
                    const platformGeom = new THREE.BoxGeometry(width, 0.3, tierDepth);
                    const platform = new THREE.Mesh(platformGeom, material);
                    platform.position.set(0, currentHeight, zOffset);
                    group.add(platform);
                    
                    // Front edge
                    const edgeGeom = new THREE.BoxGeometry(width, tierHeight, 0.1);
                    const edge = new THREE.Mesh(edgeGeom, material);
                    edge.position.set(0, currentHeight / 2, zOffset + tierDepth / 2);
                    group.add(edge);
                }
            }
            
            createGalleryWall(group, material) {
                // Larger vertical wall to accommodate bigger, more spaced objects
                const geometry = new THREE.BoxGeometry(16, 8, 0.5); // Increased from 12x6
                const mesh = new THREE.Mesh(geometry, material);
                group.add(mesh);
            }
            
            createStage(group, material, isLarge) {
                const width = isLarge ? 40 : 25;
                const depth = isLarge ? 25 : 15;
                const height = 2;
                
                // Stage platform
                const platformGeom = new THREE.BoxGeometry(width, height, depth);
                const platform = new THREE.Mesh(platformGeom, material);
                platform.position.set(0, height / 2, 0);
                group.add(platform);
                
                // Back wall
                const wallGeom = new THREE.BoxGeometry(width, 8, 0.5);
                const wall = new THREE.Mesh(wallGeom, material);
                wall.position.set(0, height + 4, -depth / 2);
                group.add(wall);
                
                // Side pillars
                const pillarGeom = new THREE.BoxGeometry(0.8, 10, 0.8);
                const leftPillar = new THREE.Mesh(pillarGeom, material);
                leftPillar.position.set(-width / 2 + 0.3, height + 5, -depth / 2 + 0.3);
                group.add(leftPillar);
                
                const rightPillar = new THREE.Mesh(pillarGeom, material);
                rightPillar.position.set(width / 2 - 0.3, height + 5, -depth / 2 + 0.3);
                group.add(rightPillar);
                
                // Roof
                const roofGeom = new THREE.BoxGeometry(width + 2, 0.5, depth / 2);
                const roof = new THREE.Mesh(roofGeom, material);
                roof.position.set(0, height + 10, -depth / 4);
                group.add(roof);
            }
            
            createAmphitheatre(group, material) {
                // Tiered semicircular seating
                const radius = 30;
                const tiers = 5;
                const tierHeight = 2;
                const tierDepth = 4;
                
                for (let tier = 0; tier < tiers; tier++) {
                    const tierRadius = radius - (tier * tierDepth);
                    const tierGeom = new THREE.CylinderGeometry(
                        tierRadius, tierRadius, tierHeight,
                        32, 1, false, 0, Math.PI
                    );
                    const tierMesh = new THREE.Mesh(tierGeom, material);
                    tierMesh.position.set(0, tier * tierHeight + tierHeight / 2, 0);
                    group.add(tierMesh);
                }

                // Add stepped back wall to match tiered structure
                for (let tier = 0; tier < tiers; tier++) {
                    const tierRadius = radius - (tier * tierDepth);
                    const wallWidth = tierRadius * 2; // Width matches this tier's diameter
                    const wallThickness = 0.5;
                    
                    const wallGeometry = new THREE.BoxGeometry(wallWidth, tierHeight, wallThickness);
                    const wallMesh = new THREE.Mesh(wallGeometry, material);
                    wallMesh.position.set(0, tier * tierHeight + tierHeight / 2, 0); // Match tier height
                    wallMesh.rotation.y = Math.PI / 2; // Rotate 90 degrees to cover the back
                    group.add(wallMesh);
                }
            }

            getStyleColor(style) {
                const colors = {
                    woodgrain: 0x8B4513,
                    marble: 0xE8E8E8,
                    metal: 0x708090,
                    glass: 0xB0C4DE,
                    neon: 0xFF1493
                };
                return colors[style] || 0x8B4513;
            }

            async createLinkObject(objData, furnitureData) {
                // Create cube for link (larger and flatter like a flat screen TV)
                const geometry = new THREE.BoxGeometry(2.8, 3.5, 0.7);
                
                // Create materials for each face
                const materials = [];
                
                // Load thumbnail texture if available
                let thumbnailTexture = null;
                let thumbnailSource = null;
                
                // Prefer thumbnailUrl (YouTube/Vimeo) with CORS proxy, fallback to thumbnailDataUrl
                if (objData.thumbnailUrl) {
                    // Proxy external URLs to avoid CORS issues
                    if (objData.thumbnailUrl.includes('ytimg.com') || objData.thumbnailUrl.includes('vimeocdn.com')) {
                        thumbnailSource = `https://api.allorigins.win/raw?url=${encodeURIComponent(objData.thumbnailUrl)}`;
                    } else {
                        thumbnailSource = objData.thumbnailUrl;
                    }
                } else if (objData.thumbnailDataUrl) {
                    thumbnailSource = objData.thumbnailDataUrl;
                }
                
                if (thumbnailSource) {
                    try {
                        thumbnailTexture = await this.loadTexture(thumbnailSource);
                    } catch (error) {
                        console.warn('Failed to load thumbnail:', error);
                        // Try fallback to thumbnailDataUrl if thumbnailUrl failed
                        if (objData.thumbnailUrl && objData.thumbnailDataUrl) {
                            try {
                                thumbnailTexture = await this.loadTexture(objData.thumbnailDataUrl);
                            } catch (e) {
                                console.warn('Fallback thumbnail also failed:', e);
                            }
                        }
                    }
                }
                
                // Create materials (6 faces)
                for (let i = 0; i < 6; i++) {
                    if (i === 4 && thumbnailTexture) {
                        // Front face with thumbnail - enhanced with border glow
                        materials.push(new THREE.MeshStandardMaterial({
                            map: thumbnailTexture,
                            metalness: 0.2,
                            roughness: 0.6,
                            emissive: 0x111111,
                            emissiveIntensity: 0.3
                        }));
                    } else {
                        // Other faces with solid color
                        materials.push(new THREE.MeshStandardMaterial({
                            color: this.getDomainColor(objData.domain),
                            metalness: 0.3,
                            roughness: 0.7,
                            emissive: 0x000000,
                            emissiveIntensity: 0
                        }));
                    }
                }
                
                const mesh = new THREE.Mesh(geometry, materials);
                
                // Calculate position based on slot
                const slotData = this.calculateSlotPosition(objData.slotIndex, furnitureData);
                if (slotData.position) {
                    mesh.position.copy(slotData.position);
                    mesh.rotation.y = slotData.rotation || 0;
                } else {
                    mesh.position.copy(slotData);
                }
                
                // Store metadata
                mesh.userData = {
                    ...objData,
                    objectIndex: this.objects.length
                };
                
                this.furniture.add(mesh); // Make object child of furniture so it rotates with it
                this.objects.push(mesh);
                
                // Create title label if displayTitle exists
                if (objData.displayTitle && this.labelManager) {
                    this.labelManager.createLabel(mesh, objData.displayTitle);
                }
            }

            createLocalMediaPlaceholder(objData, furnitureData) {
                // Create placeholder cube for local media (larger and flatter)
                const geometry = new THREE.BoxGeometry(2.8, 3.5, 0.7);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x555555,
                    metalness: 0.2,
                    roughness: 0.9,
                    opacity: 0.5,
                    transparent: true
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                
                // Calculate position
                const slotData = this.calculateSlotPosition(objData.slotIndex, furnitureData);
                if (slotData.position) {
                    mesh.position.copy(slotData.position);
                    mesh.rotation.y = slotData.rotation || 0;
                } else {
                    mesh.position.copy(slotData);
                }
                
                // Store metadata
                mesh.userData = {
                    ...objData,
                    objectIndex: this.objects.length
                };
                
                this.furniture.add(mesh); // Make object child of furniture so it rotates with it
                this.objects.push(mesh);
                
                // Create title label if displayTitle exists
                if (objData.displayTitle && this.labelManager) {
                    this.labelManager.createLabel(mesh, objData.displayTitle);
                }
            }

            calculateSlotPosition(slotIndex, furnitureData) {
                const type = furnitureData.type;
                
                switch(type) {
                    case 'bookshelf':
                        return this.calculateBookshelfSlot(slotIndex);
                    case 'riser':
                        return this.calculateRiserSlot(slotIndex);
                    case 'gallery_wall':
                        return this.calculateGalleryWallSlot(slotIndex);
                    case 'stage_small':
                    case 'stage_large':
                        return this.calculateStageSlot(slotIndex, type === 'stage_large');
                    case 'amphitheatre':
                        return this.calculateAmphitheatreSlot(slotIndex);
                    default:
                        return this.calculateGalleryWallSlot(slotIndex);
                }
            }
            
            calculateBookshelfSlot(slotIndex) {
                // 2 rows x 3 columns (6 objects total)
                const cols = 3;
                const spacingX = 6;
                const spacingY = 3.5;
                
                const col = slotIndex % cols;
                const row = Math.floor(slotIndex / cols);
                
                const x = (col - 1) * spacingX; // Center: -6, 0, 6
                const y = row * spacingY + 1.9; // On shelf (0.15 above shelf surface) + half object height (1.75)
                const z = 0.5; // In front of back panel
                
                return new THREE.Vector3(x, y, z);
            }
            
            calculateRiserSlot(slotIndex) {
                // 3 tiers, 5 objects per tier (15 total)
                const objectsPerTier = 5;
                const tier = Math.floor(slotIndex / objectsPerTier);
                const posInTier = slotIndex % objectsPerTier;
                
                const width = 24;
                const tierHeight = 1.0;
                const tierDepth = 4;
                
                const usableWidth = width * 0.85;
                const spacingX = usableWidth / (objectsPerTier - 1);
                
                const x = -usableWidth / 2 + (posInTier * spacingX);
                const y = (2 - tier) * tierHeight + 1.9; // On top of platform (0.15 above platform center) + half object height (1.75)
                const z = tierDepth * (2 - tier); // Reverse: front (tier 2) at z=0, back (tier 0) at z=8
                
                return {
                    position: new THREE.Vector3(x, y, z),
                    rotation: Math.PI // Rotate 180 degrees to face forward
                };
            }
            
            calculateGalleryWallSlot(slotIndex) {
                // 2 rows x 5 columns (10 objects) - increased spacing for larger objects
                const cols = 5;
                const spacing = 3.85; // Increased by 10% to provide clearance and prevent label overlap
                
                const col = slotIndex % cols;
                const row = Math.floor(slotIndex / cols);
                
                const x = (col - 2) * spacing; // Center: -7, -3.5, 0, 3.5, 7
                const y = (row - 0.5) * spacing; // -1.75, 1.75
                const z = 0.3;
                
                return new THREE.Vector3(x, y, z);
            }
            
            calculateStageSlot(slotIndex, isLarge) {
                const width = isLarge ? 40 : 25;
                const depth = isLarge ? 25 : 15;
                const rows = isLarge ? 7 : 4;
                const cols = isLarge ? 7 : 4;
                const platformHeight = 2;
                const spacingX = width / (cols + 1);
                const spacingZ = depth / (rows + 1);
                
                const col = slotIndex % cols;
                const row = Math.floor(slotIndex / cols);
                
                const x = -width / 2 + spacingX * (col + 1);
                const y = platformHeight + 1.75; // On top of platform + half object height (1.75)
                const z = -depth / 2 + spacingZ * (row + 1);
                
                return new THREE.Vector3(x, y, z);
            }
            
            calculateAmphitheatreSlot(slotIndex) {
                // 5 tiers, 16 seats per tier (80 total, skip tier 0)
                const seatsPerTier = 16;
                const tier = Math.floor(slotIndex / seatsPerTier) + 1; // Tiers 1-5
                const seat = slotIndex % seatsPerTier;
                
                const radius = 30;
                const tierDepth = 4;
                const tierHeight = 2;
                
                const tierRadius = radius - (tier * tierDepth) + (tierDepth - 1);
                const angleStep = Math.PI / (seatsPerTier - 1);
                const angle = seat * angleStep - Math.PI / 2;
                
                const x = tierRadius * Math.cos(angle);
                const y = (tier + 1) * tierHeight + 1.75; // On tier surface (top of cylinder) + half object height (1.75)
                const z = tierRadius * Math.sin(angle);
                
                // Calculate rotation to face outward toward front (lowest tier)
                const rotation = angle - Math.PI / 2;
                
                return {
                    position: new THREE.Vector3(x, y, z),
                    rotation: rotation
                };
            }

            getDomainColor(domain) {
                const colors = {
                    'youtube.com': 0xff0000,
                    'vimeo.com': 0x1ab7ea,
                    'soundcloud.com': 0xff8800,
                    default: 0x667eea
                };
                return colors[domain] || colors.default;
            }

            loadTexture(dataUrl) {
                return new Promise((resolve, reject) => {
                    const loader = new THREE.TextureLoader();
                    loader.load(
                        dataUrl,
                        (texture) => {
                            texture.wrapS = THREE.ClampToEdgeWrapping;
                            texture.wrapT = THREE.ClampToEdgeWrapping;
                            texture.minFilter = THREE.LinearFilter;
                            texture.magFilter = THREE.LinearFilter;
                            resolve(texture);
                        },
                        undefined,
                        (error) => reject(error)
                    );
                });
            }

            setupUI(shareData) {
                // Info panel
                document.getElementById('furniture-name').textContent = shareData.furniture.name;
                document.getElementById('furniture-type').textContent = `${shareData.furniture.type} ‚Ä¢ ${shareData.objects.length} items`;
                document.getElementById('total-objects').textContent = shareData.objects.length;
                
                const youtubeCount = shareData.objects.filter(o => o.domain === 'youtube.com').length;
                document.getElementById('youtube-count').textContent = youtubeCount;
                
                // Get the info-content container
                const infoContent = document.querySelector('#info-panel .info-content');
                
                // Add import button if we have a paste ID
                if (this.pasteId) {
                    const importBtn = document.createElement('button');
                    importBtn.className = 'import-btn';
                    importBtn.innerHTML = '<span class="import-btn-icon">üì•</span> Add to My FirstTaps World';
                    importBtn.onclick = () => {
                        const deepLink = `firsttapsmv3d://import-furniture?paste=${this.pasteId}`;
                        window.location.href = deepLink;
                    };
                    infoContent.appendChild(importBtn);
                }
                
                // Add download section
                const downloadSection = document.createElement('div');
                downloadSection.className = 'download-section';
                downloadSection.innerHTML = `
                    <p>Don't have FirstTaps MV3D?</p>
                    <div class="download-links">
                        <a href="https://play.google.com/store/apps/details?id=com.firsttaps.firsttapsmv3d&pcampaignid=web_share" 
                           class="download-link primary" 
                           target="_blank">
                            <span class="download-link-icon">üíö</span> Get on Google Play
                        </a>
                        <a href="https://www.firsttaps.com" 
                           class="download-link" 
                           target="_blank">
                            <span class="download-link-icon">üåê</span> Visit FirstTaps.com
                        </a>
                    </div>
                `;
                infoContent.appendChild(downloadSection);
                
                // Don't set inline styles - let CSS media queries handle visibility
                // CSS will show/hide the appropriate panel based on screen size
                
                // Setup mobile info panel
                document.getElementById('mobile-furniture-info').textContent = `${shareData.furniture.name}: ${shareData.objects.length} items`;
                
                // Add import button to mobile panel if we have a paste ID
                const mobileImportContainer = document.getElementById('mobile-import-container');
                if (this.pasteId) {
                    const mobileImportBtn = document.createElement('button');
                    mobileImportBtn.className = 'mobile-import-btn';
                    mobileImportBtn.innerHTML = 'üì• Add to My FirstTaps World';
                    mobileImportBtn.onclick = () => {
                        const deepLink = `firsttapsmv3d://import-furniture?paste=${this.pasteId}`;
                        window.location.href = deepLink;
                    };
                    mobileImportContainer.appendChild(mobileImportBtn);
                }
                
                // Don't set inline styles - CSS media queries control visibility
                // Both panels are populated, CSS decides which one to show
                
                // Playlist
                const playlistContainer = document.getElementById('playlist-items');
                this.objects.forEach((obj, index) => {
                    const objData = obj.userData;
                    const item = document.createElement('div');
                    item.className = 'playlist-item';
                    if (objData.isLocalMedia) {
                        item.classList.add('local-media');
                    }
                    
                    // Thumbnail
                    if ((objData.thumbnailUrl || objData.thumbnailDataUrl) && !objData.isLocalMedia) {
                        const thumb = document.createElement('img');
                        thumb.className = 'playlist-item-thumbnail';
                        
                        // Prefer thumbnailUrl (YouTube/Vimeo) with CORS proxy
                        if (objData.thumbnailUrl) {
                            if (objData.thumbnailUrl.includes('ytimg.com') || objData.thumbnailUrl.includes('vimeocdn.com')) {
                                thumb.src = `https://api.allorigins.win/raw?url=${encodeURIComponent(objData.thumbnailUrl)}`;
                            } else {
                                thumb.src = objData.thumbnailUrl;
                            }
                            // Fallback to thumbnailDataUrl if URL fails
                            thumb.onerror = () => {
                                if (objData.thumbnailDataUrl) {
                                    thumb.src = objData.thumbnailDataUrl;
                                }
                            };
                        } else {
                            thumb.src = objData.thumbnailDataUrl;
                        }
                        
                        item.appendChild(thumb);
                    } else {
                        const placeholder = document.createElement('div');
                        placeholder.className = 'playlist-item-thumbnail';
                        item.appendChild(placeholder);
                    }
                    
                    // Info
                    const info = document.createElement('div');
                    info.className = 'playlist-item-info';
                    
                    const title = document.createElement('div');
                    title.className = 'playlist-item-title';
                    title.textContent = objData.name || objData.title || 'Untitled';
                    info.appendChild(title);
                    
                    const subtitle = document.createElement('div');
                    subtitle.className = 'playlist-item-subtitle';
                    subtitle.textContent = objData.domain || 'Local Media';
                    info.appendChild(subtitle);
                    
                    // Badge
                    if (objData.isLocalMedia) {
                        const badge = document.createElement('span');
                        badge.className = 'playlist-item-badge badge-local';
                        badge.textContent = 'Local Media';
                        info.appendChild(badge);
                    } else if (objData.domain === 'youtube.com') {
                        const badge = document.createElement('span');
                        badge.className = 'playlist-item-badge badge-youtube';
                        badge.textContent = 'YouTube';
                        info.appendChild(badge);
                    } else if (objData.domain === 'vimeo.com') {
                        const badge = document.createElement('span');
                        badge.className = 'playlist-item-badge badge-vimeo';
                        badge.textContent = 'Vimeo';
                        info.appendChild(badge);
                    }
                    
                    item.appendChild(info);
                    
                    // Click handler
                    if (!objData.isLocalMedia) {
                        item.addEventListener('click', () => {
                            window.open(objData.url, '_blank');
                            this.highlightObject(index);
                        });
                    }
                    
                    playlistContainer.appendChild(item);
                });
                
                document.getElementById('playlist').style.display = 'block';
            }

            highlightObject(index) {
                // Update playlist items
                document.querySelectorAll('.playlist-item').forEach((item, i) => {
                    if (i === index) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
                
                // Animate object in 3D scene
                const object = this.objects[index];
                if (object) {
                    // Simple scale animation
                    const originalScale = object.scale.clone();
                    object.scale.set(1.2, 1.2, 1.2);
                    setTimeout(() => {
                        object.scale.copy(originalScale);
                    }, 300);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update camera position
                this.updateCameraPosition();
                
                // Apply rotation momentum/decay
                if (!this.isDragging && Math.abs(this.rotationVelocity) > 0.001) {
                    if (this.furniture) {
                        this.furniture.rotation.y += this.rotationVelocity;
                        this.rotationVelocity *= 0.95; // Decay
                    }
                }
                
                // Update label positions
                if (this.labelManager) {
                    this.labelManager.updateLabelPositions();
                }
                
                // Object hover glow effect
                this.updateObjectHover();
                
                // Gentle bob animation for objects
                this.objects.forEach((obj, index) => {
                    const time = Date.now() * 0.001;
                    obj.position.y += Math.sin(time + index) * 0.001;
                });
                
                this.renderer.render(this.scene, this.camera);
            }

            updateCameraPosition() {
                // Position camera at distance from target
                this.camera.position.set(
                    this.cameraTarget.x,
                    this.cameraTarget.y + 8,
                    this.cameraTarget.z + this.cameraDistance
                );
                this.camera.lookAt(this.cameraTarget);
            }

            setupCameraControls() {
                const moveSpeed = 2;
                
                // Direction buttons
                document.getElementById('btn-up').addEventListener('click', () => {
                    this.cameraTarget.y += moveSpeed;
                });
                
                document.getElementById('btn-down').addEventListener('click', () => {
                    this.cameraTarget.y -= moveSpeed;
                });
                
                document.getElementById('btn-left').addEventListener('click', () => {
                    this.cameraTarget.x -= moveSpeed;
                });
                
                document.getElementById('btn-right').addEventListener('click', () => {
                    this.cameraTarget.x += moveSpeed;
                });
                
                // Zoom slider
                const zoomSlider = document.getElementById('zoom-slider');
                // Initialize slider value to match current camera distance
                zoomSlider.value = this.cameraDistance;
                zoomSlider.addEventListener('input', (e) => {
                    this.cameraDistance = parseFloat(e.target.value);
                });
                
                console.log('‚úÖ Camera controls initialized');
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            showError(message) {
                document.getElementById('loading').style.display = 'none';
                const errorDiv = document.getElementById('error-message');
                errorDiv.style.display = 'block';
                document.getElementById('error-text').textContent = message;
                
                // Add download links to error message if not already present
                if (!errorDiv.querySelector('.download-section')) {
                    const downloadSection = document.createElement('div');
                    downloadSection.className = 'download-section';
                    downloadSection.style.marginTop = '24px';
                    downloadSection.innerHTML = `
                        <p>Get FirstTaps MV3D to create your own furniture playlists:</p>
                        <div class="download-links">
                            <a href="https://play.google.com/store/apps/details?id=com.firsttaps.firsttapsmv3d&pcampaignid=web_share" 
                               class="download-link primary" 
                               target="_blank">
                                <span class="download-link-icon">üíö</span> Get on Google Play
                            </a>
                            <a href="https://www.firsttaps.com" 
                               class="download-link" 
                               target="_blank">
                                <span class="download-link-icon">üåê</span> Visit FirstTaps.com
                            </a>
                        </div>
                    `;
                    errorDiv.appendChild(downloadSection);
                }
            }

            toggleView() {
                const trackListView = document.getElementById('track-list-view');
                const canvasContainer = document.getElementById('canvas-container');
                const infoPanel = document.getElementById('info-panel');
                const playlist = document.getElementById('playlist');
                const controls = document.getElementById('controls');
                
                const isTrackListVisible = trackListView.style.display === 'block';
                
                if (isTrackListVisible) {
                    // Switch to 3D view
                    trackListView.style.display = 'none';
                    canvasContainer.style.display = 'block';
                    // Remove inline styles to let CSS media queries control visibility
                    infoPanel.style.removeProperty('display');
                    playlist.style.removeProperty('display');
                    controls.style.removeProperty('display');
                } else {
                    // Switch to 2D track list view
                    this.populateTrackList();
                    trackListView.style.display = 'block';
                    canvasContainer.style.display = 'none';
                    infoPanel.style.display = 'none';
                    playlist.style.display = 'none';
                    controls.style.display = 'none';
                }
            }

            populateTrackList() {
                const container = document.getElementById('track-list-items');
                const title = document.getElementById('track-list-title');
                
                if (this.furniture && this.furniture.userData) {
                    title.textContent = this.furniture.userData.name || 'Track List';
                }
                
                container.innerHTML = '';
                
                this.objects.forEach((obj, index) => {
                    const objData = obj.userData;
                    const item = document.createElement('div');
                    item.className = 'track-item';
                    
                    // Thumbnail or icon
                    if ((objData.thumbnailUrl || objData.thumbnailDataUrl) && !objData.isLocalMedia) {
                        const thumb = document.createElement('img');
                        thumb.className = 'track-item-thumbnail';
                        
                        // Prefer thumbnailUrl (YouTube/Vimeo) with CORS proxy
                        if (objData.thumbnailUrl) {
                            if (objData.thumbnailUrl.includes('ytimg.com') || objData.thumbnailUrl.includes('vimeocdn.com')) {
                                thumb.src = `https://api.allorigins.win/raw?url=${encodeURIComponent(objData.thumbnailUrl)}`;
                            } else {
                                thumb.src = objData.thumbnailUrl;
                            }
                            // Fallback to thumbnailDataUrl if URL fails
                            thumb.onerror = () => {
                                if (objData.thumbnailDataUrl) {
                                    thumb.src = objData.thumbnailDataUrl;
                                }
                            };
                        } else {
                            thumb.src = objData.thumbnailDataUrl;
                        }
                        
                        item.appendChild(thumb);
                    } else {
                        const icon = document.createElement('div');
                        icon.className = 'track-item-icon';
                        icon.textContent = this.getObjectIcon(objData);
                        item.appendChild(icon);
                    }
                    
                    // Info
                    const info = document.createElement('div');
                    info.className = 'track-item-info';
                    
                    const title = document.createElement('div');
                    title.className = 'track-item-title';
                    title.textContent = objData.name || objData.title || `Track ${index + 1}`;
                    info.appendChild(title);
                    
                    const subtitle = document.createElement('div');
                    subtitle.className = 'track-item-subtitle';
                    subtitle.textContent = this.getObjectType(objData);
                    info.appendChild(subtitle);
                    
                    item.appendChild(info);
                    
                    // Click handler
                    if (!objData.isLocalMedia && objData.url) {
                        item.addEventListener('click', () => {
                            window.open(objData.url, '_blank');
                        });
                    } else {
                        item.style.opacity = '0.5';
                        item.style.cursor = 'not-allowed';
                    }
                    
                    container.appendChild(item);
                });
            }

            toggleInfoPanel() {
                // Deprecated - using simplified mobile panel with no toggle now
                // Mobile devices show the static simplified panel
                return;
            }

            closeInfoPanel() {
                // Deprecated - no modal behavior needed
                return;
            }

            getObjectIcon(objData) {
                if (objData.url) {
                    if (objData.url.includes('youtube.com') || objData.url.includes('youtu.be')) return 'üì∫';
                    if (objData.url.includes('spotify.com')) return 'üéµ';
                    if (objData.url.includes('tiktok.com')) return 'üé¨';
                    if (objData.url.includes('instagram.com')) return 'üì∏';
                    return 'üîó';
                }
                if (objData.extension === '.mp3') return 'üéµ';
                if (objData.extension === '.mp4') return 'üé¨';
                return 'üì¶';
            }

            getObjectType(objData) {
                if (objData.isLocalMedia) return 'Local Media (Not Shareable)';
                if (objData.url) {
                    if (objData.url.includes('youtube.com') || objData.url.includes('youtu.be')) return 'YouTube Video';
                    if (objData.url.includes('spotify.com')) return 'Spotify Track';
                    if (objData.url.includes('tiktok.com')) return 'TikTok Video';
                    if (objData.url.includes('instagram.com')) return 'Instagram Reel';
                    return objData.domain || 'Web Link';
                }
                if (objData.extension === '.mp3') return 'Audio File';
                if (objData.extension === '.mp4') return 'Video File';
                return objData.type || 'Unknown';
            }
        }

        // Initialize viewer
        window.addEventListener('DOMContentLoaded', () => {
            window.furnitureViewer = new FurnitureViewer();
        });
    </script>
</body>
</html>
